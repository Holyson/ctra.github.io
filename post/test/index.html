<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ctra王大大 | Gridea</title>
<meta name="description" content="CTRA王大大" />
<link rel="shortcut icon" href="https://holyson.github.io/ctra.github.io//favicon.ico?v=1584838259430">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://holyson.github.io/ctra.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://holyson.github.io/ctra.github.io/">
  <img class="avatar" src="https://holyson.github.io/ctra.github.io//images/avatar.png?v=1584838259430" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    CTRA王大大
  </p>
  <div class="menu-container">
    
      
        <a href="https://holyson.github.io/ctra.github.io/" class="menu">
          首页
        </a>
      
    
      
        <a href="https://holyson.github.io/ctra.github.io//tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://holyson.github.io/ctra.github.io//post/about/" class="menu">
          关于
        </a>
      
    
      
        <a href="https://holyson.github.io/ctra.github.io//archives" class="menu">
          文章
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              ctra王大大
            </h2>
            <div class="post-info">
              <span>
                2020-03-21
              </span>
              <span>
                12 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="前言">前言</h1>
<h1 id="1c基础知识">1.C++基础知识</h1>
<h3 id="11关于c">1.1	关于C++</h3>
<p>1.1.1  C++的源文件拓展名是：cpp（c plus plus的简称）<br>
1.1.2  C++程序的入口是main函数（函数即方法，一个意思）<br>
1.1.3  C++完全兼容C语言的语法，很久以前，C++叫做C with classes<br>
1.1.4  C++发展史<br>
<img src="https://img-blog.csdnimg.cn/20200321091553975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="12-第一个c程序-hello-world">1.2  第一个C++程序 hello world</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="13-cin-cout-endl-的使用">1.3  cin、cout、endl 的使用</h3>
<p>1.3.1	C++中常使用cin、cout进行控制台的输入、输出<br>
1.3.2	使用cin cout 需要依赖#include <iostream>和using namespace std;<br>
1.3.3	cin用右移运算符&gt;&gt;，cout用的是左移运算符&lt;&lt;<br>
1.3.4	endl 是换行的意思</p>
<h1 id="2函数重载-overload">2.函数重载 - Overload</h1>
<h3 id="21规则">2.1	规则</h3>
<p>2.1.1	函数名相同<br>
2.1.2	参数个数不同、参数类型不同、参数顺序不同</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int sum(int v1, int v2) {
	return v1 + v2;
}
int sum(int v1, int v2, int v3) {
	return v1 + v2 + v3;
}
int main() {
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	cout &lt;&lt; sum(10, 20,30) &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="22注意">2.2	注意</h3>
<p>2.2.1	返回值类型与函数重载无关<br>
2.2.2	调用函数时，实参的隐式类型转换可能会产生二义性<br>
<font color="red">注意： C语言不支持函数重载、C++支持函数重载</font></p>
<h3 id="23本质">2.3	本质</h3>
<p>采用了name mangling或者叫做name decoration技术<br>
重载时会生成多个不同的函数名，不同编译器（MSVC、g++）有不同的生成规则<br>
通过IDA打开[vs 下 release 禁止优化] 可以看到</p>
<p>release下会进行优化（可以禁止）<br>
debug 下可以查询所有反汇编<br>
<img src="https://img-blog.csdnimg.cn/20200321095603761.png" alt="在这里插入图片描述"></p>
<h1 id="3默认参数">3.默认参数</h1>
<h3 id="31c允许函数设置默认参数在调用时可以根据情况省略实参">3.1	C++允许函数设置默认参数，在调用时可以根据情况省略实参</h3>
<p>规则如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int sum(int v1 , int v2 = 6) {
	return v1 + v2;
}

int main() {
	cout &lt;&lt; sum(10) &lt;&lt; endl;
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	return 0;

}
</code></pre>
<h5 id="311默认参数只能按照右到左的顺序">3.1.1		默认参数只能按照右到左的顺序</h5>
<p>如下面代码<font color="red">写法错误</font>，v2的赋值不能缺失</p>
<pre><code class="language-cpp">int sum(int v1 = 10, int v2 ) { //错！！！！
	return v1 + v2;  
}
</code></pre>
<h5 id="312font-colorred如果函数同时有声明-实现默认参数只能放在函数声明中font">3.1.2		<font color="red">如果函数同时有声明、实现，默认参数只能放在函数声明中</font></h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
//声明
int sum(int v1, int v2 = 6);

int main() {
	cout &lt;&lt; sum(10) &lt;&lt; endl;
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	return 0;

}
//实现
int sum(int v1, int v2) {
	return v1 + v2;
}
</code></pre>
<h5 id="313默认参数的值可以是常量-全局符号全局变量-函数名">3.1.3		默认参数的值可以是常量、全局符号（全局变量、函数名）</h5>
<p>1）	默认参数值是全局变量</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int age = 20;
int sum(int v1, int v2 = age) {
	return v1 + v2;
}
int main() {
	cout &lt;&lt; sum(10) &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>2）	指向函数的指针调用函数<br>
(*p)(int) ：（*p）是指向函数的指针 （int）为参数类型</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int age = 20;
void  test(int a) {
	cout &lt;&lt; &quot;test(int)&quot; &lt;&lt; a &lt;&lt; endl;
}

int main() {
	void (*p)(int) = test;
	(*p)(age);
	p(age);
	return 0;

}
</code></pre>
<p>可见	(*p)(age); 和 p(age); 是一样的</p>
<pre><code class="language-c">	(*p)(age);
00111D0F 8B F4                mov         esi,esp  
00111D11 A1 00 C0 11 00       mov         eax,dword ptr ds:[0011C000h]  
00111D16 50                   push        eax  
00111D17 FF 55 F8             call        dword ptr [ebp-8]  
00111D1A 83 C4 04             add         esp,4  
00111D1D 3B F4                cmp         esi,esp  
00111D1F E8 66 F5 FF FF       call        0011128A  
	p(age);
00111D24 8B F4                mov         esi,esp  
00111D26 A1 00 C0 11 00       mov         eax,dword ptr ds:[0011C000h]  
00111D2B 50                   push        eax  
00111D2C FF 55 F8             call        dword ptr [ebp-8]  
00111D2F 83 C4 04             add         esp,4  
00111D32 3B F4                cmp         esi,esp  
00111D34 E8 51 F5 FF FF       call        0011128A
</code></pre>
<p>3）	默认参数值是函数名</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int age = 20;

void  test(int a) {
	cout &lt;&lt; &quot;test(int):&quot; &lt;&lt; a &lt;&lt; endl;
}

void func(int v1, void(*p)(int) = test) {
	p(v1);
}

int main() {
	func(30);
	return 0;

}
</code></pre>
<h3 id="32二义性">3.2	二义性</h3>
<h5 id="321函数重载-默认参数可能会产生冲突-二义性建议优先选择使用默认参数">3.2.1		函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）</h5>
<p><img src="https://img-blog.csdnimg.cn/20200321103027912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-extern-c">4. extern  &quot;C&quot;</h1>
<h3 id="41extern-c-作用">4.1	extern &quot;C&quot; 作用</h3>
<p>被 extern &quot;C&quot; 修饰的代码会按照C语言的方式去编译</p>
<h3 id="42c语言不支持重载">4.2	C语言不支持重载</h3>
<img src="https://img-blog.csdnimg.cn/20200321123306953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" width="40%" alt=""/>
<h3 id="43俩种写法">4.3	俩种写法</h3>
<pre><code class="language-cpp">extern &quot;C&quot; void func() {
}
extern &quot;C&quot; void func(int v) {
}
</code></pre>
<pre><code class="language-cpp">extern &quot;C&quot; {
	void func() {
	}
	void func(int v) {
	}
}
</code></pre>
<h3 id="44有声明和实现的函数-与-extern-c">4.4	有声明和实现的函数 与 extern &quot;C&quot;</h3>
<h5 id="441如果函数同时有声明和实现font-colorred-要让函数声明被-extern-c修饰font函数实现可以不修饰">4.4.1		如果函数同时有声明和实现，<font color="red" >要让函数声明被 extern &quot;C&quot;修饰</font>，函数实现可以不修饰</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// 函数声明
void func();
extern &quot;C&quot; void func(int v);

int main() {
	return 0;
}
// 函数实现
void func() {
}
void func(int v) {
}
</code></pre>
<h3 id="45c-c-混合开发">4.5	C、C++ 混合开发</h3>
<h5 id="451由于c-c编译规则不同在c-c混合开发时可能会经常出现以下操作">4.5.1		由于C、C++编译规则不同，在C、C++混合开发时，可能会经常出现以下操作</h5>
<p>C++在调用C语言API 时，需要使用extern “C” 修饰C语言的函数声明</p>
<p><img src="https://img-blog.csdnimg.cn/20200321125133282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
在C++ 中引用C文件，声明时需要加上extern &quot;C&quot;，否则报错<br>
<img src="https://img-blog.csdnimg.cn/2020032112583246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="452-define-__cplusplus">4.5.2 	#define __cplusplus</h5>
<p>只要在C++文件中，默认定义宏 #define __cplusplus （一般不可见）<br>
可以用这个宏来判断是否为C++文件</p>
<p>1）math.c</p>
<pre><code class="language-cpp">#include &quot;math.h&quot;
//include 是为了在.c文件中
//调用自己不报错
int sum(int v1, int v2) {
	return v1 + v2;
}
</code></pre>
<p>2）main.cpp</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

#include &quot;math.h&quot;
extern &quot;C&quot; {
	void other();
}

int main() {
	other();
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>3）math.h</p>
<pre><code class="language-cpp">
#ifdef __cplusplus
extern  &quot;C&quot; {
#endif // __cplusplus

int sum(int v1, int v2);

#ifdef __cplusplus
}
#endif // __cplusplus
</code></pre>
<p>4）math.h</p>
<pre><code class="language-cpp">#include &quot;math.h&quot;
#include &lt;stdio.h&gt;
void other() {
	int a = sum(10, 99);
	printf(&quot;a= %d\n&quot;,a);
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200321131819896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="443-防止头文件重复包含">4.4.3 	防止头文件重复包含</h5>
<p>我们经常使用 #ifndef、#define、#endif 来防止头文件的内容被重复包含</p>
<pre><code class="language-cpp">#ifndef __MATH_H
#define __MATH_H

#ifdef __cplusplus
extern  &quot;C&quot; {
#endif // __cplusplus

int sum(int v1, int v2);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __MATH_H
</code></pre>
<img src="https://img-blog.csdnimg.cn/20200321132628607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" width="60%" alt=""/>
<h5 id="444-pragma-once">4.4.4 	#pragma once</h5>
<p>#pragma once 可以防止整个文件的内容被重复包含<br>
<font color="red" >#ifndef、#define、#endif  与  #pragma once 区别 ：</font><br>
1）#ifndef、#define、#endif 受C\C++标准的支持，不收编译器的任何限制<br>
2）有些编译器不支持#pragma once （较老编译器不支持，如GCC 3.4版本之前），兼容性不够好<br>
3）#ifndef、#define、#endif 可以针对一个文件中的部分代码，而#pragma once只能针对整个文件</p>
<h1 id="5内联函数-inline-function">5.内联函数- inline function</h1>
<h3 id="51-inline-修饰符">5.1 inline 修饰符</h3>
<p>5.1.1	使用 inline 修饰函数的声明或者实现 ，可以使其变成内联函数<br>
5.1.2	建议声明和实现都增加 inline 修饰</p>
<h3 id="52-特点">5.2 特点</h3>
<p>5.2.1	编译器会将函数调用直接展开为函数体代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

inline int sum;
inline int sum(int v1, int v2) {
	return v1 + v2;
}

int main() {
	int c = sum(10, 20);
    //	等价于
	//int c =  v1 + v2;
    int c =  10 + 20;
	return 0;
}
</code></pre>
<p>5.2.2	如果不使用	inline 函数,被调用 func的函数体只会保留一份 （即：cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void func() {
	cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;
}

int main() {
	func();
    func();
	func();
    func();
    
	return 0;
}
</code></pre>
<p>5.2.3	可以减少函数调用的开销（不存在函数调用，程序直接运行函数体内容）</p>
<p>5.2.4	会增大代码体积</p>
<p><font color=red size=2>注意</font></p>
<p><font color=red size=2>1）尽量不要内联超过10行代码的函数</font></p>
<p><font color=red size=2>2）有些函数即使声明为inline 也不一定会被编译器内联，比如：递归函数</font></p>
<h3 id="53-什么时候使用内联函数">5.3 什么时候使用内联函数？</h3>
<p>5.3.1	函数代码体积不大</p>
<p>5.3.2	频繁调用的函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//====================  声明	====================
void func();
inline int sum(int v1, int v2);

//====================  实现	====================
//开辟 栈空间
void func() {
	cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;
}
//回收 栈空间

inline int sum(int v1, int v2) {
	return v1 + v2;
}

int main() {
	func();
	int c = sum(10, 20);
	cout &lt;&lt; c &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<h3 id="54-vs窥探内联的本质">5.4 VS窥探内联的本质</h3>
<h5 id="541-如果-inline-内联生效后在反汇编中应该看不到定义的函数如543内联的效果">5.4.1 	如果 inline 内联生效后，在反汇编中应该看不到定义的函数（如：5.4.3	内联的效果）</h5>
<h5 id="542如何在-vs2019-中进行设置">5.4.2		如何在 VS2019 中进行设置</h5>
<p><img src="https://img-blog.csdnimg.cn/20200320181328380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/2020032018134571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="543内联的效果">5.4.3		内联的效果</h5>
<pre><code class="language-assembly">--- E:\C++-程序\05-内联函数\05-内联函数\main.cpp -----------------------------------------
	func();
00291000  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (029305Ch)]  
00291006  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (0291320h)  
0029100B  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (0291100h)  
00291010  mov         ecx,eax  
00291012  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0293038h)]  
	int c = sum(10, 20);
	cout &lt;&lt; c &lt;&lt; endl;
00291018  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (029305Ch)]  
0029101E  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (0291320h)  
00291023  push        1Eh  
00291025  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0293034h)]  
0029102B  mov         ecx,eax  
0029102D  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0293038h)]  
	getchar();
00291033  call        dword ptr [__imp__getchar (02930F0h)]  
	return 0;
00291039  xor         eax,eax  
}
</code></pre>
<h5 id="544非内联的效果">5.4.4		非内联的效果</h5>
<pre><code class="language-assembly">	func();
01052078  call        func (01051424h)  
	int c = sum(10, 20);
0105207D  push        14h  
0105207F  push        0Ah  
01052081  call        sum (01051429h)  
01052086  add         esp,8  
01052089  mov         dword ptr [c],eax  
	cout &lt;&lt; c &lt;&lt; endl;
0105208C  mov         esi,esp  
0105208E  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (010512B7h)  
01052093  mov         edi,esp  
01052095  mov         eax,dword ptr [c]  
01052098  push        eax  
01052099  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (0105D0D8h)]  
0105209F  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0105D0A0h)]  
010520A5  cmp         edi,esp  
	cout &lt;&lt; c &lt;&lt; endl;
010520A7  call        __RTC_CheckEsp (0105128Fh)  
010520AC  mov         ecx,eax  
010520AE  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0105D0A4h)]  
010520B4  cmp         esi,esp  
010520B6  call        __RTC_CheckEsp (0105128Fh)  
</code></pre>
<h3 id="55内联函数与宏">5.5.内联函数与宏</h3>
<h5 id="551相同点内联函数和宏都能减少函数调用的开销">5.5.1		相同点：内联函数和宏都能减少函数调用的开销</h5>
<h5 id="552对比宏内联函数多了语法检测和函数特性">5.5.2		对比宏，内联函数多了语法检测和函数特性</h5>
<p><font color=red size=2>而且宏会将普通的运算改变</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

inline int sum(int v) {
	 return v  + v ;
}
//定义宏
#define add(v)(v + v)

int main() {
	int a = 10;
	int b = 10;
	int c = sum(++a);
	int d = add(++b);
	cout &lt;&lt; c &lt;&lt; endl;
	cout &lt;&lt; d &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>输出结果 ：22		24</p>
<p><font color=red size=2>可以看出宏将++a 操作复杂化了</font></p>
<h3 id="56-表达式">5.6 表达式</h3>
<h5 id="561表达式性质仅为-c特性c语言没有此性质">5.6.1		表达式性质仅为 C++特性，C语言没有此性质</h5>
<p><img src="https://img-blog.csdnimg.cn/20200320181406166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="562表达式实例1">5.6.2		表达式实例1</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//表达式
int main() {
	int a = 1;
	int b = 2;
    
	(a = b) = 4;
    
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>输出结果：a=4<br>
b=12</p>
<h5 id="563表达式实例2">5.6.3		表达式实例2</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//表达式
int main() {
	int a = 1;
	int b = 2;
    
	(a &gt; b ? a : b) = 10;
    
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>输出结果：a=1<br>
b=10</p>
<h1 id="6常量-const">6.常量 -  const</h1>
<h3 id="61-c-中的指针">6.1  C++ 中的指针</h3>
<h5 id="611回忆一下指针">6.1.1		回忆一下指针</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Date {
	int year;
	int month;
	int day;
};

int main() {
	Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };
	//p指针指向d结构体
	Date* p = &amp;d;
	//指向结构体的指针，访问结构体的成员使用 -&gt;  (语法糖)
	p-&gt;day = 99;
  //*p 就是结构体即为d 等价于 d.month =12;
	(*p).month = 12;
	//结构体本身，访问结构体的成员使用 .  (语法糖)
	cout &lt;&lt; d.day &lt;&lt; endl;
}
</code></pre>
<h3 id="62-const是什么">6.2 const是什么？</h3>
<p><font color="red">const是常量的意思，被其修饰的变量不可修改</font></p>
<p><font color="red">如果修饰的是类、结构体（的指针），其成员不可以更改</font></p>
<h5 id="611没有被-const-修饰-的结构体">6.1.1		没有被 const  修饰 的结构体</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Date {
	int year;
	int month;
	int day;
};

int main() {
	Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };
	d = d2;
	d.year = 2022;

}
</code></pre>
<h5 id="612被-const-修饰-的结构体">6.1.2		被 const 修饰 的结构体</h5>
<p>结构体不能改</p>
<p>结构体成员也不能改</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Date {
	int year;
	int month;
	int day;
};

int main() {
	const Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };
	d = d2; 			// 报错	结构体不能改-&gt;不能将d指向d2
	d.year = 2022;// 报错	结构体成员也不能改-&gt;不能操作d的成员
}

</code></pre>
<h5 id="613用const-修饰的-指针变量">6.1.3		用const 修饰的 指针变量</h5>
<h5 id="const-date-p-d-后同样等价于结构体指针变量">const Date* p = &amp;d 后同样等价于结构体指针变量</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };

	//p指针指向d结构体
	const Date* p = &amp;d;
	p-&gt;day = 99;			// 报错
	(*p).month = 12;	// 报错
	*p = d2;					// 报错
	cout &lt;&lt; d.day &lt;&lt; endl;
}
</code></pre>
<h3 id="63-const-修饰指针p-与-指针指向的存储空间p-的应用区别">6.3  const 修饰指针（p) 与 指针指向的存储空间（*p) 的应用（区别）</h3>
<h5 id="631以下5个指针分别是什么含义">6.3.1		以下5个指针分别是什么含义？</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int age = 10;
	int height = 20;

	const int *p1 = &amp;age;
	int const* p2 = &amp;age;
	int* const p3 = &amp;age;
	const int* const p4 = &amp;age;
	int const* const p5 = &amp;age;

}
</code></pre>
<p><font color="red">结论：const修饰的是其右边的内容</font></p>
<h5 id="632首先看一下">6.3.2		首先看一下</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int age = 10;
	int height = 30;

	int* const p3 = &amp;age;
  // p3所指向的存储空间的值改为20（当前p3指向 age的地址）
	*p3 = 20;	// age = 20;
  // 代码含义： 将height的地址 通过 &amp;height赋值给 p3,此时p3指向height的地址
	p3 = &amp;height; //==================此行代码报错，原因 p3是常量
	// p3所指向的存储空间的值改为40（当前p3指向 height的地址）
  *p3 = 40;	// height = 40;
}
</code></pre>
<h5 id="633五种const-修饰的归类">6.3.3		五种const 修饰的归类 	☆☆☆☆☆</h5>
<h6 id="1const-修饰指针指向的存储空间">1）const 修饰指针指向的存储空间</h6>
<h6 id="2const-修饰指针">2）const 修饰指针</h6>
<h6 id="3const-修饰指针-指针指向的存储空间">3）const 修饰指针 + 指针指向的存储空间</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int age = 10;
	int height = 20;
	// p1（指针）不是常量，*p1（指向的存储空间）是常量
  // p2（指针）不是常量，*p2（指向的存储空间）是常量
	const int *p1 = &amp;age;
	int const* p2 = &amp;age;
  // p3（指针）是常量，*p3（指向的存储空间）不是常量
	int* const p3 = &amp;age;
  // p4（指针）是常量，*p4（指向的存储空间）也是常量
  // p5（指针）是常量，*p5（指向的存储空间）也是常量
	const int* const p4 = &amp;age;
	int const* const p5 = &amp;age;
}
</code></pre>
<h5 id="634-再次理解-const修饰-指针-和-指针指向的存储空间">6.3.4 	再次理解 const修饰 指针 和 指针指向的存储空间</h5>
<p>const 修饰的是	*pstu1（指针指向的存储空间），禁止pstu1指针去修改它所指向的存储空间</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student { int age; };

int main() {
	Student stu1 = { 10 };
	Student stu2 = { 20 };
	//const 修饰的是* pstu1，禁止pstu1指针去修改它所指向的存储空间
	const Student* pstu1 = &amp;stu1;
	*pstu1 = stu2;			// 报错
	(*pstu1).age = 20;	// 报错
	pstu1-&gt;age = 30;		// 报错
	pstu1 = &amp;stu2; //正确
}
</code></pre>
<p>const 修饰的是	pstu2（指针），禁止pstu2指针去重新指向新的地址</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student { int age; };

int main() {
	Student stu1 = { 10 };
	Student stu2 = { 20 };
	//const 修饰的是* pstu1，禁止pstu1指针去修改它所指向的存储空间
	Student* const pstu2 = &amp;stu2;
	*pstu2 = stu2;		// 正确
	(*pstu2).age = 20;	// 正确
	pstu2-&gt;age = 30;	// 正确
	pstu2 = &amp;stu2; //报错
}
</code></pre>
<h1 id="7引用-reference">7.引用 -  Reference</h1>
<h3 id="71-引用reference-的本质是什么">7.1  引用Reference 的本质是什么？</h3>
<p>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是<font color=red>弱化了的指针</font></p>
<p>在C语言中，使用指针（Pointer）可以间接获取、修改某个变量的值 （在C++可用）</p>
<p>在C++语言中，使用引用（Reference）可以起到跟指针类似的功能</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int v1,int v2) {
	int tmp = v1;
	v1 = v2;
	v2 = tmp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; &quot;a=&quot;&lt;&lt;a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}

//输出：a=10,b=20
</code></pre>
<p>使用 指针（Pointer） 定义变量v1和v2</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int * v1,int *v2) {
	int tmp = *v1;
	*v1 = *v2;
	*v2 = tmp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(&amp;a, &amp;b);
	cout &lt;&lt; &quot;a=&quot;&lt;&lt;a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
//输出：a=20,b=10
</code></pre>
<p>使用 引用（Reference） 定义变量v1和v2</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int&amp; v1, int&amp; v2) {
	int tmp = v1;
	v1 = v2;
	v2 = tmp;
}

int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
//输出：a=20,b=10
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int&amp; v1, int&amp; v2) {
	int tmp = v1;
	v1 = v2;
	v2 = tmp;
}

int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	int c = 30;
	int d = 40;
	swap(c, d);
	cout &lt;&lt; &quot;c=&quot; &lt;&lt; c &lt;&lt; &quot;,d=&quot; &lt;&lt;d &lt;&lt; endl;
	getchar();
	return 0;
}
//输出：	a=20,b=10
				c=40,d=30
</code></pre>
<p>在定义“引用变量”时就赋值-即指向谁（否则 vs 中报错）</p>
<pre><code class="language-cpp">int age =10;
int &amp;refAge = age; // 定义时 赋值
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int a = 10;
	int b = 20;
	int&amp; refA = a;
	cout &lt;&lt; &quot;当前 refA=&quot; &lt;&lt; refA &lt;&lt; endl;
	refA = b; // 实际上是将 b的值20 赋值给引用变量 refA
	cout &lt;&lt; &quot;当前 refA=&quot; &lt;&lt; refA &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>一个引用占用一个指针的大小</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#1c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1.C++基础知识</a><br>
*
<ul>
<li><a href="#11%E5%85%B3%E4%BA%8Ec">1.1	关于C++</a></li>
<li><a href="#12-%E7%AC%AC%E4%B8%80%E4%B8%AAc%E7%A8%8B%E5%BA%8F-hello-world">1.2  第一个C++程序 hello world</a></li>
<li><a href="#13-cin-cout-endl-%E7%9A%84%E4%BD%BF%E7%94%A8">1.3  cin、cout、endl 的使用</a></li>
</ul>
</li>
<li><a href="#2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-overload">2.函数重载 - Overload</a><br>
*
<ul>
<li><a href="#21%E8%A7%84%E5%88%99">2.1	规则</a></li>
<li><a href="#22%E6%B3%A8%E6%84%8F">2.2	注意</a></li>
<li><a href="#23%E6%9C%AC%E8%B4%A8">2.3	本质</a></li>
</ul>
</li>
<li><a href="#3%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">3.默认参数</a><br>
*
<ul>
<li><a href="#31c%E5%85%81%E8%AE%B8%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E6%83%85%E5%86%B5%E7%9C%81%E7%95%A5%E5%AE%9E%E5%8F%82">3.1	C++允许函数设置默认参数，在调用时可以根据情况省略实参</a><br>
*
<ul>
<li><a href="#311%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%AA%E8%83%BD%E6%8C%89%E7%85%A7%E5%8F%B3%E5%88%B0%E5%B7%A6%E7%9A%84%E9%A1%BA%E5%BA%8F">3.1.1		默认参数只能按照右到左的顺序</a></li>
<li><a href="#312font-colorred%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E6%9C%89%E5%A3%B0%E6%98%8E-%E5%AE%9E%E7%8E%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%AA%E8%83%BD%E6%94%BE%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%ADfont">3.1.2		<font color="red">如果函数同时有声明、实现，默认参数只能放在函数声明中</font></a></li>
<li><a href="#313%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%B8%B8%E9%87%8F-%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0%E5%90%8D">3.1.3		默认参数的值可以是常量、全局符号（全局变量、函数名）</a></li>
</ul>
</li>
<li><a href="#32%E4%BA%8C%E4%B9%89%E6%80%A7">3.2	二义性</a><br>
*
<ul>
<li><a href="#321%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%86%B2%E7%AA%81-%E4%BA%8C%E4%B9%89%E6%80%A7%E5%BB%BA%E8%AE%AE%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">3.2.1		函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-extern-c">4. extern  &quot;C&quot;</a><br>
*
<ul>
<li><a href="#41extern-c-%E4%BD%9C%E7%94%A8">4.1	extern &quot;C&quot; 作用</a></li>
<li><a href="#42c%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%E9%87%8D%E8%BD%BD">4.2	C语言不支持重载</a></li>
<li><a href="#43%E4%BF%A9%E7%A7%8D%E5%86%99%E6%B3%95">4.3	俩种写法</a></li>
<li><a href="#44%E6%9C%89%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%BD%E6%95%B0-%E4%B8%8E-extern-c">4.4	有声明和实现的函数 与 extern &quot;C&quot;</a><br>
*
<ul>
<li><a href="#441%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E6%9C%89%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0font-colorred-%E8%A6%81%E8%AE%A9%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E8%A2%AB-extern-c%E4%BF%AE%E9%A5%B0font%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%BB%A5%E4%B8%8D%E4%BF%AE%E9%A5%B0">4.4.1		如果函数同时有声明和实现，<font color="red" >要让函数声明被 extern &quot;C&quot;修饰</font>，函数实现可以不修饰</a></li>
</ul>
</li>
<li><a href="#45c-c-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91">4.5	C、C++ 混合开发</a><br>
*
<ul>
<li><a href="#451%E7%94%B1%E4%BA%8Ec-c%E7%BC%96%E8%AF%91%E8%A7%84%E5%88%99%E4%B8%8D%E5%90%8C%E5%9C%A8c-c%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%97%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E6%93%8D%E4%BD%9C">4.5.1		由于C、C++编译规则不同，在C、C++混合开发时，可能会经常出现以下操作</a></li>
<li><a href="#452-define-__cplusplus">4.5.2 	#define __cplusplus</a></li>
<li><a href="#443-%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB">4.4.3 	防止头文件重复包含</a></li>
<li><a href="#444-pragma-once">4.4.4 	#pragma once</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline-function">5.内联函数- inline function</a><br>
*
<ul>
<li><a href="#51-inline-%E4%BF%AE%E9%A5%B0%E7%AC%A6">5.1 inline 修饰符</a></li>
<li><a href="#52-%E7%89%B9%E7%82%B9">5.2 特点</a></li>
<li><a href="#53-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">5.3 什么时候使用内联函数？</a></li>
<li><a href="#54-vs%E7%AA%A5%E6%8E%A2%E5%86%85%E8%81%94%E7%9A%84%E6%9C%AC%E8%B4%A8">5.4 VS窥探内联的本质</a><br>
*
<ul>
<li><a href="#541-%E5%A6%82%E6%9E%9C-inline-%E5%86%85%E8%81%94%E7%94%9F%E6%95%88%E5%90%8E%E5%9C%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%AD%E5%BA%94%E8%AF%A5%E7%9C%8B%E4%B8%8D%E5%88%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82543%E5%86%85%E8%81%94%E7%9A%84%E6%95%88%E6%9E%9C">5.4.1 	如果 inline 内联生效后，在反汇编中应该看不到定义的函数（如：5.4.3	内联的效果）</a></li>
<li><a href="#542%E5%A6%82%E4%BD%95%E5%9C%A8-vs2019-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE">5.4.2		如何在 VS2019 中进行设置</a></li>
<li><a href="#543%E5%86%85%E8%81%94%E7%9A%84%E6%95%88%E6%9E%9C">5.4.3		内联的效果</a></li>
<li><a href="#544%E9%9D%9E%E5%86%85%E8%81%94%E7%9A%84%E6%95%88%E6%9E%9C">5.4.4		非内联的效果</a></li>
</ul>
</li>
<li><a href="#55%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F">5.5.内联函数与宏</a><br>
*
<ul>
<li><a href="#551%E7%9B%B8%E5%90%8C%E7%82%B9%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E9%83%BD%E8%83%BD%E5%87%8F%E5%B0%91%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80">5.5.1		相同点：内联函数和宏都能减少函数调用的开销</a></li>
<li><a href="#552%E5%AF%B9%E6%AF%94%E5%AE%8F%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%A4%9A%E4%BA%86%E8%AF%AD%E6%B3%95%E6%A3%80%E6%B5%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7">5.5.2		对比宏，内联函数多了语法检测和函数特性</a></li>
</ul>
</li>
<li><a href="#56-%E8%A1%A8%E8%BE%BE%E5%BC%8F">5.6 表达式</a><br>
*
<ul>
<li><a href="#561%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%A7%E8%B4%A8%E4%BB%85%E4%B8%BA-c%E7%89%B9%E6%80%A7c%E8%AF%AD%E8%A8%80%E6%B2%A1%E6%9C%89%E6%AD%A4%E6%80%A7%E8%B4%A8">5.6.1		表达式性质仅为 C++特性，C语言没有此性质</a></li>
<li><a href="#562%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B1">5.6.2		表达式实例1</a></li>
<li><a href="#563%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B2">5.6.3		表达式实例2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6%E5%B8%B8%E9%87%8F-const">6.常量 -  const</a><br>
*
<ul>
<li><a href="#61-c-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88">6.1  C++ 中的指针</a><br>
*
<ul>
<li><a href="#611%E5%9B%9E%E5%BF%86%E4%B8%80%E4%B8%8B%E6%8C%87%E9%92%88">6.1.1		回忆一下指针</a></li>
</ul>
</li>
<li><a href="#62-const%E6%98%AF%E4%BB%80%E4%B9%88">6.2 const是什么？</a><br>
*
<ul>
<li><a href="#611%E6%B2%A1%E6%9C%89%E8%A2%AB-const-%E4%BF%AE%E9%A5%B0-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93">6.1.1		没有被 const  修饰 的结构体</a></li>
<li><a href="#612%E8%A2%AB-const-%E4%BF%AE%E9%A5%B0-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93">6.1.2		被 const 修饰 的结构体</a></li>
<li><a href="#613%E7%94%A8const-%E4%BF%AE%E9%A5%B0%E7%9A%84-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F">6.1.3		用const 修饰的 指针变量</a></li>
<li><a href="#const-date-p-d-%E5%90%8E%E5%90%8C%E6%A0%B7%E7%AD%89%E4%BB%B7%E4%BA%8E%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F">const Date* p = &amp;d 后同样等价于结构体指针变量</a></li>
</ul>
</li>
<li><a href="#63-const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88p-%E4%B8%8E-%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4p-%E7%9A%84%E5%BA%94%E7%94%A8%E5%8C%BA%E5%88%AB">6.3  const 修饰指针（p) 与 指针指向的存储空间（*p) 的应用（区别）</a><br>
*
<ul>
<li><a href="#631%E4%BB%A5%E4%B8%8B5%E4%B8%AA%E6%8C%87%E9%92%88%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89">6.3.1		以下5个指针分别是什么含义？</a></li>
<li><a href="#632%E9%A6%96%E5%85%88%E7%9C%8B%E4%B8%80%E4%B8%8B">6.3.2		首先看一下</a></li>
<li><a href="#633%E4%BA%94%E7%A7%8Dconst-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%BD%92%E7%B1%BB">6.3.3		五种const 修饰的归类 	☆☆☆☆☆</a>
<ul>
<li><a href="#1const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4">1）const 修饰指针指向的存储空间</a></li>
<li><a href="#2const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88">2）const 修饰指针</a></li>
<li><a href="#3const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4">3）const 修饰指针 + 指针指向的存储空间</a></li>
</ul>
</li>
<li><a href="#634-%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3-const%E4%BF%AE%E9%A5%B0-%E6%8C%87%E9%92%88-%E5%92%8C-%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4">6.3.4 	再次理解 const修饰 指针 和 指针指向的存储空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7%E5%BC%95%E7%94%A8-reference">7.引用 -  Reference</a><br>
*
<ul>
<li><a href="#71-%E5%BC%95%E7%94%A8reference-%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88">7.1  引用Reference 的本质是什么？</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://holyson.github.io/ctra.github.io//post/hello-gridea">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://holyson.github.io/ctra.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      console.log('section.offsetHeight', section.offsetHeight);
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
