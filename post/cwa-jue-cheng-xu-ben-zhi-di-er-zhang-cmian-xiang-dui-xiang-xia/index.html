<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>C++挖掘程序本质（第二章C++面向对象-下） | CTRA王大大`blog</title>
<meta name="description" content="CTRA王大大">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://holyson.github.io/ctra.github.io//favicon.ico?v=1586571605567">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://holyson.github.io/ctra.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://holyson.github.io/ctra.github.io/">
        <img src="https://holyson.github.io/ctra.github.io//images/avatar.png?v=1586571605567" class="site-logo">
        <h1 class="site-title">CTRA王大大`blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://holyson.github.io/ctra.github.io/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://holyson.github.io/ctra.github.io//tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://holyson.github.io/ctra.github.io//post/about/" class="site-nav">
            关于
          </a>
        
      
        
          <a href="https://holyson.github.io/ctra.github.io//archives" class="site-nav">
            文章
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      CTRA王大大
    </div>
    <div class="site-footer">
      Powered by <a href="https://holyson.github.io/ctra.github.io/" target="_blank">ctra王大大</a> | <a class="rss" href="https://holyson.github.io/ctra.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">C++挖掘程序本质（第二章C++面向对象-下）</h2>
            <div class="post-date">2020-04-11</div>
            
              <div class="feature-container" style="background-image: url('https://holyson.github.io/ctra.github.io//post-images/cwa-jue-cheng-xu-ben-zhi-di-er-zhang-cmian-xiang-dui-xiang-xia.png')">
              </div>
            
            <div class="post-content">
              <!-- more -->
<p>这是关于c++学习的配套教材，想学习教程的朋友可以留言，或关注公众号：ctra 私信我即可</p>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#1%E5%A4%9A%E7%BB%A7%E6%89%BF">1.多继承</a><br>
*
<ul>
<li><a href="#11-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">1.1 多继承下内存布局</a></li>
<li><a href="#12-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">1.2 多继承体系下构造函数调用</a></li>
<li><a href="#13-%E5%A4%9A%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0">1.3  多继承-虚函数</a></li>
<li><a href="#14-%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0">1.4  同名函数</a></li>
<li><a href="#15-%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8Fc%E5%85%81%E8%AE%B8">1.5  同名成员变量（C++允许）</a></li>
</ul>
</li>
<li><a href="#2-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF">2. 菱形继承</a><br>
*
<ul>
<li><a href="#21-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">2.1  菱形继承带来的问题</a></li>
<li><a href="#22-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%89%96%E6%9E%90">2.2  菱形继承内存剖析</a></li>
</ul>
</li>
<li><a href="#3-%E8%99%9A%E7%BB%A7%E6%89%BF">3. 虚继承</a><br>
*
<ul>
<li><a href="#31-%E8%99%9A%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%89%96%E6%9E%90">3.1  虚继承内存剖析</a><br>
*
<ul>
<li><a href="#311-%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%A7%E6%89%BF">3.1.1 虚继承与继承</a></li>
<li><a href="#312-%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%AD-%E5%AD%90%E7%B1%BB%E4%B8%8E%E7%88%B6%E7%B1%BB">3.1.2 虚继承中 子类与父类</a></li>
<li><a href="#313-%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E8%99%9A%E8%A1%A8">3.1.3 虚继承中虚表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-static">4. 静态成员 （static）</a><br>
*
<ul>
<li><a href="#41-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">4.1 静态成员变量</a><br>
*
<ul>
<li><a href="#411-%E5%AD%98%E5%82%A8%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%85%A8%E5%B1%80%E5%8C%BA-%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%95%B4%E4%B8%AA%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%BD%E5%86%85%E5%AD%98">4.1.1 存储在数据段（全局区、类似于全局变量），整个程序运行过程中只有一份内存</a></li>
<li><a href="#412-%E5%AF%B9%E6%AF%94%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%83%E5%8F%AF%E4%BB%A5%E8%AE%BE%E5%AE%9A%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90public-protect-private%E8%BE%BE%E5%88%B0%E5%B1%80%E9%83%A8%E5%85%B1%E4%BA%AB%E7%9A%84%E7%9B%AE%E7%9A%84">4.1.2  对比全局变量，它可以设定访问权限（public、protect、private），达到局部共享的目的</a></li>
<li><a href="#413-%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E4%B8%8D%E8%83%BD%E5%B8%A6static">4.1.3  必须初始化，必须在类外面初始化，初始化时不能带static</a></li>
</ul>
</li>
<li><a href="#42-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">4.2 静态成员函数</a><br>
*
<ul>
<li><a href="#421%E5%86%85%E9%83%A8%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8this%E6%8C%87%E9%92%88">4.2.1	内部不能使用this指针</a></li>
<li><a href="#422%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0">4.2.2	不能是虚函数</a></li>
<li><a href="#423%E5%86%85%E9%83%A8%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0">4.2.3	内部不能访问非静态成员变量、函数，只能访问静态成员变量、函数</a></li>
<li><a href="#424%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0">4.2.4	非静态成员函数内部可以访问静态成员变量、函数</a></li>
<li><a href="#425%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E9%9D%99%E6%80%81">4.2.5	构造函数、析构函数不能是静态</a></li>
<li><a href="#426%E5%BD%93%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB%E6%97%B6%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86%E4%B8%8D%E8%83%BD%E5%B8%A6static">4.2.6	当声明和实现分离时，实现部分不能带static</a></li>
</ul>
</li>
<li><a href="#43-%E7%AA%A5%E6%8E%A2%E5%8F%8D%E6%B1%87%E7%BC%96">4.3 窥探反汇编</a><br>
*
<ul>
<li><a href="#431-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8">4.3.1 静态成员变量与非静态成员变量的本质</a></li>
<li><a href="#431-%E5%90%8C%E4%B8%80%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%89%96%E6%9E%90%E5%8F%8D%E6%B1%87%E7%BC%96">4.3.1 同一静态成员变量，剖析反汇编</a></li>
</ul>
</li>
<li><a href="#44%E7%AA%A5%E6%8E%A2%E5%86%85%E5%AD%98">4.4	窥探内存</a><br>
*
<ul>
<li><a href="#441-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8B%E4%B8%8D%E5%90%8C%E7%B1%BB%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80">4.4.1 继承关系下，不同类调用静态变量的地址</a></li>
<li><a href="#442-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8B%E5%AD%90%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%88%B6%E7%B1%BB%E5%90%8C%E5%90%8D%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">4.4.2 继承关系下，子类定义与父类同名的静态成员</a></li>
</ul>
</li>
<li><a href="#45%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">4.5	应用场景</a><br>
*
<ul>
<li><a href="#451-%E7%BB%9F%E8%AE%A1car%E7%9A%84%E6%95%B0%E9%87%8F">4.5.1	 统计car的数量</a></li>
<li><a href="#452-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">4.5.2	 单例模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-const%E6%88%90%E5%91%98">5. const成员</a><br>
*
<ul>
<li><a href="#51-const%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">5.1  const成员变量</a><br>
*
<ul>
<li><a href="#511-%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%86%85%E9%83%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%A3%B0%E6%98%8E%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B5%8B%E5%80%BC">5.1.1  必须初始化（类内部初始化），可以再声明的时候直接初始化赋值</a></li>
<li><a href="#512-%E9%9D%9Estatic-%E7%9A%84-const-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96">5.1.2  非static 的 const 成员变量还可以在初始化列表中初始化</a></li>
<li><a href="#513-static-%E4%BF%AE%E9%A5%B0%E7%9A%84-const-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A3%B0%E6%98%8E%E6%97%B6%E5%AE%9A%E4%B9%89">5.1.3   static 修饰的 const 成员变量只能在声明时定义</a></li>
</ul>
</li>
<li><a href="#52-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%9D%9E%E9%9D%99%E6%80%81">5.2  const成员函数（非静态）</a><br>
*
<ul>
<li><a href="#521-font-colorblueconstfont%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%99%E5%9C%A8%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E5%90%8E%E9%9D%A2%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%BF%85%E9%A1%BB%E5%B8%A6font-colorblueconstfont">5.2.1  <font color=blue>const</font>关键字写在参数列表后面，函数的声明和实现必须带<font color=blue>const</font></a></li>
<li><a href="#522-%E5%86%85%E9%83%A8%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%E9%9D%9Efont-colorbluestaticfont%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">5.2.2	 内部不能修改非<font color=blue>static</font>成员变量</a></li>
<li><a href="#523-%E5%86%85%E9%83%A8%E5%8F%AA%E8%83%BD%E8%B0%83%E7%94%A8font-colorblueconstfont%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2.3	 内部只能调用<font color=blue>const</font>成员函数，static成员函数</a></li>
<li><a href="#524-%E9%9D%9Econst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2.4	 非const成员函数可以调用const成员函数</a></li>
<li><a href="#525-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%9Econst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9E%84%E6%88%90%E9%87%8D%E8%BD%BD">5.2.5	 const成员函数和非const成员函数构成重载</a></li>
<li><a href="#526-%E9%9D%9Econst%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BC%98%E5%85%88%E8%B0%83%E7%94%A8%E9%9D%9Econst-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2.6	 非const对象（指针）优先调用非const 成员函数</a></li>
<li><a href="#527-const%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E5%8F%AA%E8%83%BD%E8%B0%83%E7%94%A8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2.7	 const对象（指针）只能调用const成员函数、static成员函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98">6. 引用类型成员</a><br>
*
<ul>
<li><a href="#61-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E8%80%83%E8%99%91static%E6%83%85%E5%86%B5">6.1 引用类型成员变量必须初始化（不考虑static情况）</a></li>
<li><a href="#62-%E5%9C%A8%E5%A3%B0%E6%98%8E%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96">6.2 在声明的时候直接初始化</a></li>
<li><a href="#63-%E9%80%9A%E8%BF%87%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96">6.3 通过初始化列表初始化</a></li>
</ul>
</li>
<li><a href="#7-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0copy-constructor">7. 拷贝构造函数（Copy Constructor）</a><br>
*
<ul>
<li><a href="#71%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96">7.1	构造函数初始化</a><br>
*
<ul>
<li><a href="#711-%E5%88%A9%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8E%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E4%BC%9A%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">7.1.1 利用对象去初始化，不会调用构造函数</a></li>
</ul>
</li>
<li><a href="#72%E5%88%A9%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8E%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">7.2	利用对象去构造函数初始化的对象（不使用拷贝构造）</a></li>
<li><a href="#73%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96">7.3	拷贝构造函数初始化</a><br>
*
<ul>
<li><a href="#731-%E5%BD%93%E5%88%A9%E7%94%A8font-colorred%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AF%B9%E8%B1%A1font%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAfont-colorred%E6%96%B0%E5%AF%B9%E8%B1%A1font%E6%97%B6%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%8B%B7%E8%B4%9D%E5%B0%B1%E4%BC%9A%E8%B0%83%E7%94%A8%E6%96%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">7.3.1  当利用<font color=red>已存在的对象</font>创建一个<font color=red>新对象</font>时（类似于拷贝），就会调用新对象的拷贝构造函数进行初始化</a></li>
</ul>
</li>
<li><a href="#74-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">7.4  拷贝构造使用场景：</a></li>
<li><a href="#75%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">7.5	调用父类的拷贝构造函数</a></li>
</ul>
</li>
<li><a href="#8-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D">8. 浅拷贝、深拷贝</a><br>
*
<ul>
<li><a href="#81-%E7%BC%96%E8%AF%91%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9Dshallow-copy">8.1  编译器默认的提供的拷贝是浅拷贝（shallow copy）</a><br>
*
<ul>
<li><a href="#811-font-colorred%E5%A0%86%E7%A9%BA%E9%97%B4%E6%8C%87%E5%90%91%E6%A0%88%E7%A9%BA%E9%97%B4%E5%BE%88%E5%8D%B1%E9%99%A9font">8.1.1  <font color=red>堆空间指向栈空间（很危险）</font></a></li>
<li><a href="#812-strcpy%E5%9C%A8vs2019%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">8.1.2  strcpy在vs2019中的使用</a></li>
<li><a href="#813-%E5%9C%A8%E5%A0%86%E7%A9%BA%E9%97%B4-%E5%A0%86%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%A0%86%E7%A9%BA%E9%97%B4-%E6%A0%88%E7%A9%BA%E9%97%B4">8.1.3  在堆空间-&gt;堆空间与堆空间-&gt;栈空间</a></li>
<li><a href="#813-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8A%A0%E4%B8%8A-const-%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">8.1.3  构造函数参数加上 const 同时接收字符串和字符数组</a></li>
</ul>
</li>
<li><a href="#82-%E6%B5%85%E6%8B%B7%E8%B4%9Dshallow-copy">8.2  浅拷贝（shallow copy）</a><br>
*
<ul>
<li><a href="#821-double-free-%E5%8F%8C%E9%87%8D%E6%9E%90%E6%9E%84%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE">8.2.1  double free 双重析构双重释放</a></li>
</ul>
</li>
<li><a href="#83-%E6%B7%B1%E6%8B%B7%E8%B4%9Ddeep-copy">8.3  深拷贝（deep copy）</a><br>
*
<ul>
<li><a href="#831-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">8.3.1  深拷贝使用场景</a></li>
</ul>
</li>
<li><a href="#84-%E6%80%BB%E7%BB%93">8.4  总结</a><br>
*
<ul>
<li><a href="#841-%E7%BC%96%E8%AF%91%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9Dshallow-copy">8.4.1  编译器默认的提供的拷贝是浅拷贝（shallow copy）</a></li>
<li><a href="#842-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9Ddeep-copy%E5%B0%B1%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">8.4.2  如果需要实现深拷贝（deep copy），就需要自定义拷贝构造函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#9-%E5%AF%B9%E8%B1%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC">9. 对象型参数和返回值</a><br>
*
<ul>
<li><a href="#91-%E5%AF%B9%E8%B1%A1%E5%9E%8B%E5%8F%82%E6%95%B0">9.1 对象型参数</a></li>
<li><a href="#92-%E5%AF%B9%E8%B1%A1%E5%9E%8B%E8%BF%94%E5%9B%9E%E5%80%BC">9.2 对象型返回值</a></li>
<li><a href="#93-%E5%A4%9A%E6%AD%A4%E4%BA%A7%E7%94%9F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E4%BC%98%E5%8C%96">9.3 多此产生拷贝构造的优化</a></li>
</ul>
</li>
<li><a href="#10-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1">10. 匿名对象（临时对象）</a><br>
*
<ul>
<li><a href="#101-%E4%BC%A0%E5%85%A5%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">10.1  传入匿名对象</a></li>
<li><a href="#102-%E8%BF%94%E5%9B%9E%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">10.2  返回匿名对象</a></li>
</ul>
</li>
<li><a href="#11-%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0">11. 隐式构造</a><br>
*
<ul>
<li><a href="#111-%E6%AD%A3%E5%B8%B8%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">11.1 正常创建对象</a></li>
<li><a href="#112-%E9%9A%90%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8int%E7%B1%BB%E5%9E%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">11.2 隐式的调用int类型构造函数</a></li>
<li><a href="#113-%E5%AF%B9%E8%B1%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E9%9A%90%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8">11.3 对象型参数（隐式的调用）</a></li>
<li><a href="#114-%E5%AF%B9%E8%B1%A1%E5%9E%8B%E8%BF%94%E5%9B%9E%E5%80%BC%E9%9A%90%E5%BC%8F%E7%9A%84%E8%B0%83%E7%94%A8">11.4 对象型返回值（隐式的调用）</a></li>
<li><a href="#115-%E5%85%88%E6%98%BE%E7%A4%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%8D%E9%9A%90%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">11.5 先显示创建对象，再隐式创建对象</a></li>
<li><a href="#116-font-colorredexplicitfont-%E7%A6%81%E6%AD%A2%E8%B0%83%E7%94%A8%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0">11.6  <font color=red>explicit</font>  禁止调用隐式构造</a></li>
</ul>
</li>
<li><a href="#12-%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">12. 编译器自动生成的构造函数</a><br>
*
<ul>
<li><a href="#121-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%9C%A8%E5%A3%B0%E6%98%8E%E7%9A%84%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%88%9D%E5%A7%8B%E5%8C%96">12.1 成员变量在声明的同时进行了初始化</a></li>
<li><a href="#122-%E6%9C%89%E5%AE%9A%E4%B9%89%E8%99%9A%E5%87%BD%E6%95%B0">12.2 有定义虚函数</a></li>
<li><a href="#123-%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%86%E5%85%B6%E4%BB%96%E7%B1%BB">12.3 虚继承了其他类</a></li>
<li><a href="#124-%E5%8C%85%E5%90%AB%E4%BA%86%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E4%B8%94%E8%BF%99%E4%B8%AA%E6%88%90%E5%91%98%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E6%88%96%E8%87%AA%E5%AE%9A%E4%B9%89">12.4 包含了对象类型的成员，且这个成员有构造函数（编译器生成或自定义）</a></li>
<li><a href="#125-%E7%88%B6%E7%B1%BB%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E6%88%96%E8%87%AA%E5%AE%9A%E4%B9%89">12.5 父类有构造函数（编译器生成或自定义）</a></li>
<li><a href="#126-%E6%80%BB%E7%BB%93">12.6 总结</a></li>
</ul>
</li>
<li><a href="#13%E5%8F%8B%E5%85%83">13.	友元</a><br>
*
<ul>
<li><a href="#131-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">13.1 友元函数</a></li>
<li><a href="#132-%E5%8F%8B%E5%85%83%E7%B1%BB">13.2 友元类</a></li>
<li><a href="#133-%E5%88%A9%E5%BC%8A">13.3 利弊</a></li>
</ul>
</li>
<li><a href="#14-%E5%86%85%E9%83%A8%E7%B1%BB">14. 内部类</a><br>
*
<ul>
<li><a href="#141-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">14.1 使用场景</a></li>
<li><a href="#142-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9">14.2 内部类的特点</a><br>
*
<ul>
<li><a href="#1421-%E6%94%AF%E6%8C%81public-protected-private%E6%9D%83%E9%99%90">14.2.1  支持public、protected、private权限</a></li>
<li><a href="#1422-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%85%B6%E5%A4%96%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%88%90%E5%91%98%E5%8F%8D%E8%BF%87%E6%9D%A5%E5%88%99%E4%B8%8D%E8%A1%8C">14.2.2  成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</a></li>
<li><a href="#1423-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%B8%8D%E5%B8%A6%E7%B1%BB%E5%90%8D-%E5%AF%B9%E8%B1%A1%E5%90%8D%E8%AE%BF%E9%97%AE%E5%85%B6%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84static%E6%88%90%E5%91%98">14.2.3  成员函数可以直接不带类名、对象名访问其外部类的static成员</a></li>
<li><a href="#1424-%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">14.2.4  不会影响外部类的内存布局</a></li>
<li><a href="#1425-%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%A4%96%E9%83%A8%E7%B1%BB%E5%86%85%E9%83%A8%E5%A3%B0%E6%98%8E%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%A4%96%E9%9D%A2%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">14.2.5  可以再外部类内部声明，在外部类外面进行定义</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-%E5%B1%80%E9%83%A8%E7%B1%BB">15. 局部类</a><br>
*
<ul>
<li><a href="#151-%E5%B1%80%E9%83%A8%E7%B1%BB%E5%BE%97%E7%89%B9%E7%82%B9">15.1 局部类得特点</a><br>
*
<ul>
<li><a href="#1511-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%85%E9%99%90%E4%BA%8E%E6%89%80%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8">15.1.1  作用域仅限于所在函数内部</a></li>
<li><a href="#1512-%E5%85%B6%E6%89%80%E6%9C%89%E7%9A%84%E6%88%90%E5%91%98%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%86%85%E9%83%A8%E4%B8%8D%E5%85%81%E8%AE%B8%E5%AE%9A%E4%B9%89font-colorbluestaticfont%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">15.1.2  其所有的成员必须定义在类内部，不允许定义<font color=blue>static</font>成员变量</a></li>
<li><a href="#1513-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8Ffont-colorbluestaticfont-%E5%8F%98%E9%87%8F%E9%99%A4%E5%A4%96">15.1.3  成员函数不能直接访问函数的局部变量（<font color=blue>static</font> 变量除外）</a></li>
<li><a href="#1514-%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">15.1.4  不会影响外部类的内存布局</a></li>
<li><a href="#1515-%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%A4%96%E9%83%A8%E7%B1%BB%E5%86%85%E9%83%A8%E5%A3%B0%E6%98%8E%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%A4%96%E9%9D%A2%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89">15.1.5  可以再外部类内部声明，在外部类外面进行定义</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(目录)</p>
<h1 id="前言">前言</h1>
<blockquote>
<p>由于在CSDN上无法看到markdown的目录，有需要额小伙伴可以联系我，附送本文的 .md文件，可以再本地typora上更加方便的学习<br>
这篇文章和  <a href="https://blog.csdn.net/wanglei19891210/article/details/104981895">汇编入门基础（点此链接）</a> 为想结合内容，请大家在学习时可以同时参考</p>
</blockquote>
<h1 id="1多继承">1.多继承</h1>
<p>C++允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student {
	int m_score;
	void study() {
		cout &lt;&lt; &quot;Student::study() - score = &quot; &lt;&lt; m_score &lt;&lt; endl;
	}
};

struct Worker {
	int m_salary;
	void work() {
		cout &lt;&lt; &quot;Worker::Worker() - salary = &quot; &lt;&lt; m_salary &lt;&lt; endl;
	}
};

struct Undergraduate :Student,Worker {
	int m_grade;
	void play() {
		cout &lt;&lt; &quot;undergraduate::play() - grade = &quot; &lt;&lt; m_grade&lt;&lt;endl;
	}
};

int main() {

	Undergraduate ug;
	ug.m_score = 100;
	ug.m_salary = 2000;
	ug.m_grade = 4;

	ug.study();
	ug.work();
	ug.play();

	return 0;
}
</code></pre>
<pre><code>输出：
Student::study() - score = 100
Worker::Worker() - salary = 2000
undergraduate::play() - grade = 4
</code></pre>
<h3 id="11-多继承下内存布局">1.1 多继承下内存布局</h3>
<p>根据继承的先后顺序，先继承的在内存的前面（和父类定义的顺序无关）</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403111812973.png" width="90%" alt=""/>
</center>
<h3 id="12-多继承体系下构造函数调用">1.2 多继承体系下构造函数调用</h3>
<p>一般情况由于封装，父类的成员变量为私有，只能用构造函数去调用父类成员变量</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student {
	int m_score;
	Student(int score) :m_score(score) {}
	void study(){
		cout &lt;&lt; &quot;Student::study() - score = &quot; &lt;&lt; m_score &lt;&lt; endl;
	}
};

struct Worker {
	int m_salary;
	Worker(int salary) :m_salary(salary) {}
	void work() {
		cout &lt;&lt; &quot;Worker::Worker() - salary = &quot; &lt;&lt; m_salary &lt;&lt; endl;
	}
};

struct Undergraduate :Student,Worker {
	int m_grade;
	//一般情况下，父类的成员变量为私有，只能用构造函数去调用
	Undergraduate(int score, int salary, int grade) :m_grade(grade), Student(score), Worker(salary) {}
	void play() {
		cout &lt;&lt; &quot;undergraduate::play() - grade = &quot; &lt;&lt; m_grade&lt;&lt;endl;
	}
};

int main() {
	return 0;
}
</code></pre>
<p>如图可见：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403142340942.png" width="90%" alt=""/>
</center>
<h3 id="13-多继承-虚函数">1.3  多继承-虚函数</h3>
<p>如果子类继承的多个父类都有虚函数，那么子类对象就会产生对应的多张虚表（地址）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Student {
public:
	virtual void study() {
		cout &lt;&lt; &quot;Student::study()&quot; &lt;&lt; endl;
	}
};

class Worker {
public:
	virtual void worker() {
		cout &lt;&lt; &quot;Worker::work()&quot; &lt;&lt; endl;
	}
};

class Undergraduate :public Student, public Worker {
public:
	void study() {
		cout &lt;&lt; &quot;Worker::work()&quot; &lt;&lt; endl;
	}
	virtual void worker() {
		cout &lt;&lt; &quot;Worker::work()&quot; &lt;&lt; endl;
	}
	virtual void play() {
		cout &lt;&lt; &quot;Undergraduate::play()&quot; &lt;&lt; endl;
	}
};

int main() {
	cout &lt;&lt; sizeof(Undergraduate) &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code>输出：8
</code></pre>
<p>如图可见：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403144030179.png" width="90%" alt=""/>
</center>
如果子类没有重写父类函数
如下代码：
<pre><code class="language-cpp">class Student {
public:
	virtual void study() {
		cout &lt;&lt; &quot;Student::study()&quot; &lt;&lt; endl;
	}
};

class Worker {
public:
	virtual void worker() {
		cout &lt;&lt; &quot;Worker::work()&quot; &lt;&lt; endl;
	}
};

class Undergraduate :public Student, public Worker {
public:
	void study() {
		cout &lt;&lt; &quot;Undergraduate ::work()&quot; &lt;&lt; endl;
	}
};
</code></pre>
<pre><code>cout &lt;&lt; sizeof(Undergraduate) &lt;&lt; endl; 
仍然输出：8
</code></pre>
<p>此时虚表地址1：存放的是父类 Student 的虚函数地址<br>
此时虚表地址2：存放的是父类 Worker 的虚函数地址</p>
<h3 id="14-同名函数">1.4  同名函数</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Student {
public:
	 void eat() {
		cout &lt;&lt; &quot;Student::eat()&quot; &lt;&lt; endl;
	}
};

class Worker {
public:
	 void eat() {
		cout &lt;&lt; &quot;Worker::eat()&quot; &lt;&lt; endl;
	}
};

class Undergraduate :public Student, public Worker {
public:
	void eat() {
		cout &lt;&lt; &quot;Undergraduate::work()&quot; &lt;&lt; endl;
	}

};

int main() {
	Undergraduate ug;
	ug.eat(); // 默认为当前对象的类型
	ug.Student::eat();
	ug.Worker::eat();
	ug.Undergraduate::eat();

	return 0;
}
</code></pre>
<pre><code>输出：
Undergraduate::work()
Student::eat()
Worker::eat()
Undergraduate::work()
</code></pre>
<h3 id="15-同名成员变量c允许">1.5  同名成员变量（C++允许）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student {
	int m_age;
};
struct Worker {
	int m_age;
};
struct Undergraduate:Student ,Worker {
	int m_age;
};

int main() {
	cout &lt;&lt; sizeof(Undergraduate) &lt;&lt; endl;
	Undergraduate ug;
	ug.m_age = 10;
	ug.Student::m_age = 11;
	ug.Worker::m_age = 12;
	ug.Undergraduate::m_age = 12;

	return 0;
}
</code></pre>
<pre><code>输出：12
</code></pre>
<p>汇编剖析：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403150403184.png" width="90%" alt=""/>
</center>
<p>内存剖析：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403150517176.png" width="90%" alt=""/>
</center>
<h1 id="2-菱形继承">2. 菱形继承</h1>
<h3 id="21-菱形继承带来的问题">2.1  菱形继承带来的问题</h3>
<p>菱形继承带来的问题：<br>
1）最底下子类从基类继承的成员变量<font color=red>冗余、重复</font><br>
2）最底下子类无法访问基类的成员，有二义性</p>
<div>
<left>
<img src="https://img-blog.csdnimg.cn/20200403151004931.png" width="45%" alt=""/>
<right>
<img src="https://img-blog.csdnimg.cn/20200403151111302.png" width="45%" alt=""/>
</div>
<p>二义性：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403151413324.png" width="70%" alt=""/>
</center>
<h3 id="22-菱形继承内存剖析">2.2  菱形继承内存剖析</h3>
<center>
<img src="https://img-blog.csdnimg.cn/20200403151804513.png" width="80%" alt=""/>
</center>
<p>代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
	int m_age;
};
struct Student:Person {
	int m_score;
};
struct Worker :Person {
	int m_salary;
};
struct Undergraduate :Student, Worker {
	int m_grade;
};

int main() {
	Undergraduate ug;
	cout &lt;&lt; sizeof(ug) &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：12
</code></pre>
<h1 id="3-虚继承">3. 虚继承</h1>
<p>虚继承可以解决菱形继承带来的问题<br>
Person 类被称为<font color=red>虚基类</font></p>
<center>
<img src="https://img-blog.csdnimg.cn/20200403152833493.png" width="80%" alt=""/>
</center>
<p>代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
	int m_age;
};
struct Student: virtual Person {
	int m_score;
};
struct Worker :virtual Person {
	int m_salary;
};
struct Undergraduate :Student, Worker {
	int m_grade;
};

int main() {
	Undergraduate ug;
	ug.m_age = 10;
	return 0;
}
</code></pre>
<pre><code>如上代码
struct Student: virtual Person  
与 
struct Worker :virtual Person 
只要有一个不是虚继承，则破坏虚继承结构，导致调用基类成员变量产生二义性
</code></pre>
<h3 id="31-虚继承内存剖析">3.1  虚继承内存剖析</h3>
<h5 id="311-虚继承与继承">3.1.1 虚继承与继承</h5>
<p><font color=red>1）虚继承：父类成员变量放最后<br>
2）继承：父类成员变量放最前面</font></p>
<h5 id="312-虚继承中-子类与父类">3.1.2 虚继承中 子类与父类</h5>
<p>代码片段分析：</p>
<pre><code class="language-cpp">// 父类
struct Person {
	int m_age;
};
// 子类
struct Student: virtual Person {
	int m_score;
};
</code></pre>
<div>
<left>
此时 Student 类的内存大小为 12个字节 <right>
<img src="https://img-blog.csdnimg.cn/20200403153944557.png" width="40%" alt=""/>
</div>
即：4+4+4（x86下虚表地址4个字节，父类Person 的 m_age 占4个字节，子类Student 的 m_score 占4个字节）
<h5 id="313-虚继承中虚表">3.1.3 虚继承中虚表</h5>
<p><font color=red>1)	虚表指针与本类起始的偏移量（一般是0）</font><br>
<font color=green>2)	虚基类第一成员变量与本类起始的偏移量</font></p>
<pre><code class="language-cpp">// 父类
struct Person {
	int m_age;
};
// 子类
struct Student: virtual Person {
	int m_score;
};
</code></pre>
 <center>
<img src="https://img-blog.csdnimg.cn/20200403154520571.png" width="60%" alt=""/>
</center>
<p>虚表中0，表示虚表指针 与 student 类的起始指针 是一样的差为0<br>
虚表中8，表示虚基类 Person 第一个成员变量m_age 与 本类 Student的起始指针 相差（8个字节，即：虚表指针4字节+m-score 4个字节）</p>
<p>全部代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
	int m_age=1;
};
struct Student: virtual Person {
	int m_score=2;
};
struct Worker :virtual Person {
	int m_salary=3;
};
struct Undergraduate :Student, Worker {
	int m_grade=4;
};

int main() {
	Undergraduate ug;
	cout &lt;&lt; sizeof(Undergraduate) &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code>输出：24
</code></pre>
<p>内存剖析：</p>
 <center>
<img src="https://img-blog.csdnimg.cn/20200403161554739.png" width="70%" alt=""/>
</center>
<h1 id="4-静态成员-static">4. 静态成员 （static）</h1>
<p>静态成员：被<font color=red>static</font>修饰的成员变量、函数</p>
<p>如何调用：<br>
1）通过对象：对象.静态成员<br>
2）通过对象指针：对象指针-&gt;静态成员<br>
3）通过类访问：类型::静态成员</p>
<p>静态成员与全局变量、函数<br>
<font color=red>唯一区别就是：增加访问限制，仅此而已</font></p>
<h3 id="41-静态成员变量">4.1 静态成员变量</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	static int m_price;
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

// 在类的外面初始化成员变量
int Car::m_price = 0;

int main() {
	Car car1;
	car1.m_price = 10;

	Car car2;
	car2.m_price = 20;

	Car car3;
	car3.m_price = 30;
	
	cout &lt;&lt; Car::m_price &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code>输出：30
</code></pre>
<h5 id="411-存储在数据段全局区-类似于全局变量整个程序运行过程中只有一份内存">4.1.1 存储在数据段（全局区、类似于全局变量），整个程序运行过程中只有一份内存</h5>
<h5 id="412-对比全局变量它可以设定访问权限public-protect-private达到局部共享的目的">4.1.2  对比全局变量，它可以设定访问权限（public、protect、private），达到局部共享的目的</h5>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406142002785.png" width="70%" alt=""/>
</center>
<h5 id="413-必须初始化必须在类外面初始化初始化时不能带static">4.1.3  必须初始化，必须在类外面初始化，初始化时不能带static</h5>
<p>如果类的声明和实现分离（在实现的 .cpp 中初始化）</p>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406140809147.png" width="70%" alt=""/>
</center>
---
<h3 id="42-静态成员函数">4.2 静态成员函数</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	static int m_price;
	static void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

// 在类的外面初始化成员变量
int Car::m_price = 0;

int main() {
	Car car1;
	car1.run();

	Car *car2;
	car2-&gt;run();

	Car::run();

	return 0;
}
</code></pre>
<pre><code>输出：
run()
run()
run()
</code></pre>
<h5 id="421内部不能使用this指针">4.2.1	内部不能使用this指针</h5>
<p><font color= blue> this </font> 指针只能用在非静态成员函数内部</p>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406143700278.png" width="70%" alt=""/>
</center>
<p>默认在类内部调用成员变量会有this指针<br>
由于static变量内存在全局区，所以不存在this指针，所以不能调用非静态成员</p>
<h5 id="422不能是虚函数">4.2.2	不能是虚函数</h5>
<p>虚函数只能是非静态成员函数</p>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406143917648.png" width="70%" alt=""/>
</center>
<h5 id="423内部不能访问非静态成员变量-函数只能访问静态成员变量-函数">4.2.3	内部不能访问非静态成员变量、函数，只能访问静态成员变量、函数</h5>
 <center>
<img src="https://img-blog.csdnimg.cn/2020040614435581.png" width="70%" alt=""/>
</center>
<h5 id="424非静态成员函数内部可以访问静态成员变量-函数">4.2.4	非静态成员函数内部可以访问静态成员变量、函数</h5>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406144718547.png" width="70%" alt=""/>
</center>
<h5 id="425构造函数-析构函数不能是静态">4.2.5	构造函数、析构函数不能是静态</h5>
<h5 id="426当声明和实现分离时实现部分不能带static">4.2.6	当声明和实现分离时，实现部分不能带static</h5>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406145055397.png" width="70%" alt=""/>
</center>
<p>（修订：图中在Car中，静态成员函数不应该有{} 主体）</p>
<h3 id="43-窥探反汇编">4.3 窥探反汇编</h3>
<h5 id="431-静态成员变量与非静态成员变量的本质">4.3.1 静态成员变量与非静态成员变量的本质</h5>
<p>对于非静态成员变量：将值写入ebp（基址指针寄存器(extended base pointer)）<br>
对于静态成员变量：将值写入 ds（全局区、数据段：data segment ）</p>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406145742932.png" width="70%" alt=""/>
</center>
<h5 id="431-同一静态成员变量剖析反汇编">4.3.1 同一静态成员变量，剖析反汇编</h5>
 <center>
<img src="https://img-blog.csdnimg.cn/20200406150734518.png" width="70%" alt=""/>
</center>
<h3 id="44窥探内存">4.4	窥探内存</h3>
<h5 id="441-继承关系下不同类调用静态变量的地址">4.4.1 继承关系下，不同类调用静态变量的地址</h5>
<p>因为静态成员在全局区（代码段）所以内存是唯一的</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
public:
	static int m_age;

};
int Person::m_age = 20;
class Student:public Person {

};

int main() {
	cout &lt;&lt; &amp;Student::m_age &lt;&lt; endl;
	cout &lt;&lt; &amp;Person::m_age &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：
00BEA000
00BEA000
</code></pre>
<h5 id="442-继承关系下子类定义与父类同名的静态成员">4.4.2 继承关系下，子类定义与父类同名的静态成员</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
public:
	static int m_age;

};
int Person::m_age = 20;
class Student:public Person {
public:
	static int m_age;

};

int Student::m_age = 30;

int main() {

	cout &lt;&lt; &amp;Student::m_age &lt;&lt; endl;
	cout &lt;&lt; &amp;Person::m_age &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：
013AA03C
013AA038
</code></pre>
<h3 id="45应用场景">4.5	应用场景</h3>
<h5 id="451-统计car的数量">4.5.1	 统计car的数量</h5>
<p>ms定义 静态成员变量<br>
m：member<br>
s：static</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// 如果写在全局区，任意函数都可以修改
//int g_count;

class Car {
	static int ms_count;
public:
	static int getCount() {
		return ms_count;
	}
	Car() {
		ms_count ++ ;
	}
	~Car() {
		ms_count--;
	}
};
int Car::ms_count = 0;
Car car;
int main() {
	Car car;

	Car* car1 = new Car();
	delete car1;

	cout &lt;&lt; Car::getCount() &lt;&lt; endl;
	return 0;
}
</code></pre>
<h5 id="452-单例模式">4.5.2	 单例模式</h5>
<p>第一步，保证类永远只创建一个对象</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//单例模式：设计模式的一种，保证某个类永远只创建一个对象
//1.构造函数私有化

class Rocket {
	Rocket() {}
	~Rocket() {}
	static Rocket* ms_rocket;
public:
	static int  ms_price;
	static Rocket* sharedRocket() {
		if (ms_rocket == NULL) {
			ms_rocket = new  Rocket();
		}
		return ms_rocket;
	}
};
//初始化static变量
Rocket* Rocket::ms_rocket = NULL;

int main() {
	//Rocket rp;
	Rocket * p1 = Rocket::sharedRocket();
	Rocket* p2 = Rocket::sharedRocket();
	Rocket* p3 = Rocket::sharedRocket();
	Rocket* p4 = Rocket::sharedRocket();
	cout &lt;&lt; p1 &lt;&lt; endl;
	cout &lt;&lt; p2 &lt;&lt; endl;
	cout &lt;&lt; p3 &lt;&lt; endl;
	cout &lt;&lt; p4 &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：
001B3AF0
001B3AF0
001B3AF0
001B3AF0
说明四个类都指向一个地址
</code></pre>
<p>第二步，定义一个私有的static成员变量指向唯一的那个单例对象</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//单例模式：设计模式的一种，保证某个类永远只创建一个对象
//1.构造函数私有化
//2.定义一个私有的static成员变量指向唯一的那个单例对象
//3.提供一个公共的访问单例对象的接口

class Rocket {
	Rocket() {}
	//防止未创建对象前，去delete
	~Rocket() {}
	static Rocket* ms_rocket;
public:
	static int  ms_price;
	static Rocket* sharedRocket() {
		//这里要考虑多线程安全
		if (ms_rocket == NULL) {
			ms_rocket = new  Rocket();
		}
		return ms_rocket;
	}

	static void deleteRocket() {
		//这里要考虑多线程安全
		if (ms_rocket!=NULL) {
			// 清空指针指向的堆空间，可能会产生野指针
			delete ms_rocket;
			// 清空指针存的地址
			ms_rocket = NULL;
		}
	}

	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};
//初始化static变量
Rocket* Rocket::ms_rocket = NULL;


int main() {
	Rocket* p1 = Rocket::sharedRocket();
	Rocket* p2 = p1-&gt;sharedRocket();
	cout &lt;&lt; p1 &lt;&lt; endl;
	cout &lt;&lt; p2 &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：
0142A6F0
0142A6F0
</code></pre>
<pre><code class="language-cpp">class Rocket {
	Rocket() {}
	//防止未创建对象前，去delete
	~Rocket() {}
	static Rocket  ms_rocket;
}
</code></pre>
<p>为什么不能使用 ：static Rocket  ms_rocket;<br>
因为堆空间更好管理，单例模式建议使用：static Rocket *  ms_rocket;</p>
<h1 id="5-const成员">5. const成员</h1>
<p>const成员：被const修饰的成员变量、非静态成员函数</p>
<h3 id="51-const成员变量">5.1  const成员变量</h3>
<h5 id="511-必须初始化类内部初始化可以再声明的时候直接初始化赋值">5.1.1  必须初始化（类内部初始化），可以再声明的时候直接初始化赋值</h5>
<p>初始化方式一，声明时直接初始化</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	//初始化方式一
	const int m_price=0;
	Car() {}
};

int main() {
	return 0;
}
</code></pre>
<h5 id="512-非static-的-const-成员变量还可以在初始化列表中初始化">5.1.2  非static 的 const 成员变量还可以在初始化列表中初始化</h5>
<p>初始化方式二，构造函数的初始化列表中初始化</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	//初始化方式一
	const int m_price;
	Car():m_price(0){}
};

int main() {
	return 0;
}
</code></pre>
<h5 id="513-static-修饰的-const-成员变量只能在声明时定义">5.1.3   static 修饰的 const 成员变量只能在声明时定义</h5>
 <center>
<img src="https://img-blog.csdnimg.cn/20200407101601528.png" width="70%" alt=""/>
</center>
<p>如下代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	//初始化方式一
	static const int m_price=0;
	Car() {}
};

int main() {
	return 0;
}
</code></pre>
<h3 id="52-const成员函数非静态">5.2  const成员函数（非静态）</h3>
<h5 id="521-font-colorblueconstfont关键字写在参数列表后面函数的声明和实现必须带font-colorblueconstfont">5.2.1  <font color=blue>const</font>关键字写在参数列表后面，函数的声明和实现必须带<font color=blue>const</font></h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	//初始化方式一
	static const int m_price=0;
	Car() {}
	void run() const;
};

void Car::run() const {
	cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
}

int main() {
	return 0;
}
</code></pre>
<h5 id="522-内部不能修改非font-colorbluestaticfont成员变量">5.2.2	 内部不能修改非<font color=blue>static</font>成员变量</h5>
<center>
<img src="https://img-blog.csdnimg.cn/20200407103724960.png" width="70%" alt=""/>
</center>
<h5 id="523-内部只能调用font-colorblueconstfont成员函数static成员函数">5.2.3	 内部只能调用<font color=blue>const</font>成员函数，static成员函数</h5>
<p>const 成员函数 不能调用非static、const函数</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200407103926408.png" width="70%" alt=""/>
</center>
<p>const 成员函数 可以调用非static函数<br>
因为static 函数不可以调用普通成员变量（只能调用 static 成员）</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200407104134289.png" width="70%" alt=""/>
</center>
<p>const可以调用static函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	//初始化方式一
	int m_price;
	Car() {}
	void test() const{
		run();
	}
	static void run()  {
	
	}
};

int main() {
	return 0;
}
</code></pre>
<p>非const成员可与</p>
<h5 id="524-非const成员函数可以调用const成员函数">5.2.4	 非const成员函数可以调用const成员函数</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	//初始化方式一
	int m_price;
	Car() {}
	void test() const{
		
	}
	void run()  {
		test();
	}
};

int main() {
	return 0;
}
</code></pre>
<h5 id="525-const成员函数和非const成员函数构成重载">5.2.5	 const成员函数和非const成员函数构成重载</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	void run()  {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
	void run() const {
		cout &lt;&lt; &quot;run() const&quot; &lt;&lt; endl;
	}
};
int main() {
	Car car1;
	car1.run();

	const Car car2;
	car2.run();

	return 0;
}
</code></pre>
<pre><code>输出：
run()
run() const
</code></pre>
<h5 id="526-非const对象指针优先调用非const-成员函数">5.2.6	 非const对象（指针）优先调用非const 成员函数</h5>
<p>当非const对象没有可调用的非const函数，则可以调用const成员函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	/*void run()  {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}*/

	void run() const {
		cout &lt;&lt; &quot;run() const&quot; &lt;&lt; endl;
	}
};

int main() {
	Car car1;
	car1.run();
	const Car car2;
	car2.run();
	return 0;
}
</code></pre>
<h5 id="527-const对象指针只能调用const成员函数-static成员函数">5.2.7	 const对象（指针）只能调用const成员函数、static成员函数</h5>
<center>
<img src="https://img-blog.csdnimg.cn/20200407112905998.png" width="70%" alt=""/>
</center>
<p>代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	void run()  {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
	void run() const {
		cout &lt;&lt; &quot;run() const&quot; &lt;&lt; endl;
	}
	static void test() {
	}
};

int main() {
	Car car1;
	car1.run();

	const Car car2;
	car2.run();
	car2.test();

	return 0;
}
</code></pre>
<h1 id="6-引用类型成员">6. 引用类型成员</h1>
<h3 id="61-引用类型成员变量必须初始化不考虑static情况">6.1 引用类型成员变量必须初始化（不考虑static情况）</h3>
<h3 id="62-在声明的时候直接初始化">6.2 在声明的时候直接初始化</h3>
<h3 id="63-通过初始化列表初始化">6.3 通过初始化列表初始化</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person{
	int age;
	int&amp; m_price = age;
public:
	Person(int&amp; price) :m_price(price) { }
}
int main() {
	return 0;
}
</code></pre>
<h1 id="7-拷贝构造函数copy-constructor">7. 拷贝构造函数（Copy Constructor）</h1>
<p>拷贝构造函数是构造函数的一种<br>
<font color=red><br>
构造函数：在创建完对象时(初始化）创建<br>
拷贝构造函数：利用一个已经存在的对象，来创建一个新对象<br>
</font></p>
<h3 id="71构造函数初始化">7.1	构造函数初始化</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
	int m_length;
public:
	Car(int price = 0, int length = 0) :m_price(price), m_length(length) {
		cout &lt;&lt; &quot;Car(int price = 0, int length = 0) &quot; &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;Price=&quot; &lt;&lt; m_price &lt;&lt; &quot;,length=&quot; &lt;&lt; m_length &lt;&lt; endl;
	}
};

int main() {
	//构造函数是在创建完对象时
	Car car1;
	Car car2(100);
	Car car3(100,5);

	return 0;
}
</code></pre>
<pre><code>输出：
Car(int price = 0, int length = 0)
Car(int price = 0, int length = 0)
Car(int price = 0, int length = 0)
</code></pre>
<h5 id="711-利用对象去初始化不会调用构造函数">7.1.1 利用对象去初始化，不会调用构造函数</h5>
<center>
<img src="https://img-blog.csdnimg.cn/20200407121029780.png" width="70%" alt=""/>
</center>
<h3 id="72利用对象去构造函数初始化的对象不使用拷贝构造">7.2	利用对象去构造函数初始化的对象（不使用拷贝构造）</h3>
<p>如：Car car4(car3);</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
	int m_length;
public:
	Car(int price = 0, int length = 0) :m_price(price), m_length(length) {
		cout &lt;&lt; &quot;Car(int price = 0, int length = 0) &quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	/*Car(const Car&amp; car) {
		cout &lt;&lt; &quot;Car(const Car&amp; car) &quot; &lt;&lt; endl;
	}*/
	void display() {
		cout &lt;&lt; &quot;Price=&quot; &lt;&lt; m_price &lt;&lt; &quot;,length=&quot; &lt;&lt; m_length &lt;&lt; endl;
	}
};

int main() {
	//构造函数是在创建完对象时
	Car car1;
	Car car2(100);
	Car car3(100,5);
	//利用已经存在的car 对象创建一个car4新对象
	//car4初始化时会调用拷贝构造函数
	Car car4(car3);
	car4.display();

	return 0;
}
</code></pre>
<pre><code>输出：
Car(int price = 0, int length = 0)
Car(int price = 0, int length = 0)
Car(int price = 0, int length = 0)
Price=100,length=5
</code></pre>
<p>反汇编剖析</p>
<pre><code class="language-c">    32: 	Car car4(car3);
 mov         eax,dword ptr [ebp-30h]  
 mov         dword ptr [ebp-40h],eax  
 mov         ecx,dword ptr [ebp-2Ch]  
 mov         dword ptr [ebp-3Ch],ecx  
    33: 	car4.display();
 lea         ecx,[ebp-40h]  
 call        00F0141A  
</code></pre>
<p>从反汇编可以得出<br>
eax,dword ptr [ebp-30h]  与 ecx,dword ptr [ebp-2Ch]<br>
相差4个字节（x86下）都取出4个字节（dword）<br>
给了另外相差4个字节的<br>
dword ptr [ebp-40h],eax 与 dword ptr [ebp-3Ch],ecx<br>
等同于</p>
<pre><code class="language-cpp">	Car car4(car3);
	car4.m_price = car3.m_price;
	car4.m_length = car3.m_length;
</code></pre>
<p>将car3的成员变量给car4，完成拷贝</p>
<h3 id="73拷贝构造函数初始化">7.3	拷贝构造函数初始化</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
	int m_length;
public:
	Car(int price = 0, int length = 0) :m_price(price), m_length(length) {
		cout &lt;&lt; &quot;Car(int price = 0, int length = 0) &quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Car(const Car&amp; car) {
		cout &lt;&lt; &quot;Car(const Car&amp; car) &quot; &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;Price=&quot; &lt;&lt; m_price &lt;&lt; &quot;,length=&quot; &lt;&lt; m_length &lt;&lt; endl;
	}
};

int main() {
	//利用已经存在的car 对象创建一个car4新对象
	//car4初始化时会调用拷贝构造函数
	Car car3(100, 5);
	Car car4(car3);
	car4.display();

	return 0;
}
</code></pre>
<pre><code>输出：
Car(int price = 0, int length = 0)
Car(const Car&amp; car)  // 调用拷贝构造
Price=-858993460,length=-858993460 
</code></pre>
<p>price 和 length输出为cc<br>
<font color=red>栈空间初始化为cc</font></p>
<h5 id="731-当利用font-colorred已存在的对象font创建一个font-colorred新对象font时类似于拷贝就会调用新对象的拷贝构造函数进行初始化">7.3.1  当利用<font color=red>已存在的对象</font>创建一个<font color=red>新对象</font>时（类似于拷贝），就会调用新对象的拷贝构造函数进行初始化</h5>
<p><font color=red>拷贝构造函数</font>中使用<font color=red>初始化列表</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
	int m_length;
public:
	Car(int price = 0, int length = 0) :m_price(price), m_length(length) {
		cout &lt;&lt; &quot;Car(int price = 0, int length = 0) &quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Car(const Car&amp; car):m_price(car.m_price),m_length(car.m_length) {
		cout &lt;&lt; &quot;Car(const Car&amp; car) &quot; &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;Price=&quot; &lt;&lt; m_price &lt;&lt; &quot;,length=&quot; &lt;&lt; m_length &lt;&lt; endl;
	}
};


int main() {
	//利用已经存在的car 对象创建一个car4新对象
	//car4初始化时会调用拷贝构造函数
	Car car3(100, 5);
	Car car4(car3);

	car4.display();

	return 0;
}
</code></pre>
<h3 id="74-拷贝构造使用场景">7.4  拷贝构造使用场景：</h3>
<p>如果全部需要将成员变量在创建对象时初始化，则不需要使用拷贝构造函数<br>
如果部分需要将成员变量在创建对象时初始化，则需要使用拷贝构造函数</p>
<h3 id="75调用父类的拷贝构造函数">7.5	调用父类的拷贝构造函数</h3>
<p>父类和子类的成员变量应该为私有，公有只为调试使用</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
	//int m_age;
public:
	int m_age;
	Person(int age=0) :m_age(age) { }
	//拷贝构造
	Person(const Person &amp;person) :m_age(person.m_age) { }
};

class Student :public Person {
	//int m_score;
public:
	int m_score;
	Student(int age = 0,int score=0) :Person(age),m_score(score) {}
	//拷贝构造
	Student(const Student &amp;student) :Person(student), m_score(student.m_score) {}
};


int main() {
	Student stu1(18, 100);
	Student stu2(stu1);
	cout &lt;&lt; stu2.m_age &lt;&lt; endl;
	cout &lt;&lt; stu2.m_score &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code>输出:
18
100
</code></pre>
<p>如果不使用拷贝构造，仍可以初始化父类的所有的成员变量</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	int m_length;
	Car(int price = 0, int length = 0) :m_price(price), m_length(length) {
		cout &lt;&lt; &quot;Car(int price = 0, int length = 0)&quot; &lt;&lt; endl;
	}
	Car(const Car &amp;car) :m_price(car.m_price), m_length(car.m_length) {
		cout &lt;&lt; &quot;Car(const Car &amp;car)&quot; &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;price=&quot; &lt;&lt; m_price &lt;&lt; &quot;, length=&quot; &lt;&lt; m_length &lt;&lt; endl;
	}
};

int main() {
	Car car1(100, 5);
	Car car2(car1);
	Car car3 = car2;
	Car car4;
	car4 = car3;

	return 0;
}
</code></pre>
<pre><code>输出：
Car(int price = 0, int length = 0)
Car(const Car &amp;car)
Car(const Car &amp;car)
Car(int price = 0, int length = 0)
</code></pre>
<table>
<thead>
<tr>
<th>对象</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>Car car1(100, 5);<br>Car car2(car1);<br>Car car3 = car2;<br>Car car4;</td>
<td>Car(int price = 0, int length = 0)<br>Car(const Car &amp;car)<br>Car(const Car &amp;car)<br>	Car(int price = 0, int length = 0)</td>
</tr>
</tbody>
</table>
<p><font color=red>这里 来进一步理解一下：car4 = car3;</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	int m_length;
	Car(int price = 0, int length = 0) :m_price(price), m_length(length) {
		cout &lt;&lt; &quot;Car(int price = 0, int length = 0)&quot; &lt;&lt; endl;
	}
	Car(const Car &amp;car) :m_price(car.m_price), m_length(car.m_length) {
		cout &lt;&lt; &quot;Car(const Car &amp;car)&quot; &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;price=&quot; &lt;&lt; m_price &lt;&lt; &quot;, length=&quot; &lt;&lt; m_length &lt;&lt; endl;
	}
};

int main() {
	Car car1(100, 5);
	Car car2(car1);
	Car car3 = car2;
	Car car4;

	car4.display();
	car4 = car3;
	car4.display();
	return 0;
}
</code></pre>
<pre><code>输出：
Car(int price = 0, int length = 0)
Car(const Car &amp;car)
Car(const Car &amp;car)
Car(int price = 0, int length = 0)
price=0, length=0
price=100, length=5
</code></pre>
<p>car4 = car3; 不满足利用一个已经存在的对象，去初始化一个新对象<br>
所以这里只是单纯的赋值（并没有调用拷贝构造函数）</p>
<h1 id="8-浅拷贝-深拷贝">8. 浅拷贝、深拷贝</h1>
<h3 id="81-编译器默认的提供的拷贝是浅拷贝shallow-copy">8.1  编译器默认的提供的拷贝是浅拷贝（shallow copy）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
public:
	Car(int price = 0, char* name = NULL) :m_price(price), m_name(name) { }
	void display() {
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is&quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};

int main() {
	const char* name1 = &quot;bmw&quot;; // 字符串需要用const修饰
	// 存放在栈空间
	char name[] = { 'b','m','w','\0' }; // name 和 name2 等价，\0为字符串结束 name2比name字符串长度多1
	//cout &lt;&lt; strlen(name) &lt;&lt; endl;
	Car* car = new Car(100, name);

	return 0;
}
</code></pre>
<p>如上代码执行的，内存分布<br>
char name[] 的 name存储在<font color=red>栈</font>空间<br>
Car* car的 car指针存储在<font color=red>栈</font>空间</p>
<h5 id="811-font-colorred堆空间指向栈空间很危险font">8.1.1  <font color=red>堆空间指向栈空间（很危险）</font></h5>
<center>
<img src="https://img-blog.csdnimg.cn/20200407161548679.png" width="80%" alt=""/>
</center
<!-- more -->
>
如图所示：栈空间的car指针指向了堆空间的car对象，堆空间中car对象的m_name指向了name数组
这种做法很危险：堆空间指向栈空间（栈空间无法自己控制生命周期，堆空间可以）
<p>可见当栈空间回收后，如下图代码执行结果：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200407162544733.png" width="80%" alt=""/>
</center>
代码如下：
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
public:
	Car(int price = 0, char* name = NULL) :m_price(price), m_name(name) { }
	void display() { 
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is &quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};
Car* g_car;
void test(){
	char name[] = { 'b','m','w','\0' }; 
	g_car = new Car(100, name);
}

int main() {
	test();
	g_car-&gt;display();

	return 0;
}
</code></pre>
<pre><code>g_car = new Car(100, name); 
</code></pre>
<p>堆空间中 name 指针没有回收，所以效果如下图：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200407162928984.png" width="80%" alt=""/>
</center>
如上图中堆空间m_name指向空，此时成为<font color=red>野指针</font>
<p>改进后将堆空间的m_name指向堆空间新开辟的一块内存存放 name 数组，如下图：</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200407163743964.png" width="80%" alt=""/>
</center>
<h5 id="812-strcpy在vs2019中的使用">8.1.2  strcpy在vs2019中的使用</h5>
<center>
<img src="https://img-blog.csdnimg.cn/20200407165145757.png" width="80%" alt=""/>
</center>
<center>
<img src="https://img-blog.csdnimg.cn/20200407165338362.png" width="80%" alt=""/>
</center>
<h5 id="813-在堆空间-堆空间与堆空间-栈空间">8.1.3  在堆空间-&gt;堆空间与堆空间-&gt;栈空间</h5>
<p>1）堆空间-&gt;堆空间，不会被栈空间回收所影响堆空间中的指针，导致<font color=red>野指针</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
public:

	Car(int price = 0, char* name = NULL) :m_price(price) { 
		if (name == NULL) return;
		//申请新的堆空间
		m_name = new char[strlen(name) + 1]{};// 使用 {} 可以保证最后一个字符是 \0
		//拷贝字符串数据到新的堆空间
		strcpy(m_name, name);
	}
	void display() { 
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is &quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};

int main() {

	char name[] = { 'b','w','m','\0' };
	Car* car = new Car(100, name);
	//test();
	car-&gt;display();

	return 0;
}
</code></pre>
<p>内存剖析</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200408134945831.png" width="80%" alt=""/>
</center>
<p>2）堆空间-&gt;栈空间，会被栈空间回收所影响堆空间中的指针，导致<font color=red>野指针</font>产生</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
public:
	Car(int price = 0, char* name = NULL) :m_price(price), m_name(name) { 

	}
	void display() { 
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is &quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};

int main() {

	char name[] = { 'b','w','m','\0' };
	Car* car = new Car(100, name);

	car-&gt;display();

	return 0;
}
</code></pre>
<p>内存剖析</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200408140217481.png" width="80%" alt=""/>
</center>
<h5 id="813-构造函数参数加上-const-同时接收字符串和字符数组">8.1.3  构造函数参数加上 const 同时接收字符串和字符数组</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
public:

	Car(int price = 0,const char* name = NULL) :m_price(price) { 
		if (name == NULL) return;
		//申请新的堆空间
		m_name = new char[strlen(name) + 1]{};// 使用 {} 可以保证最后一个字符是 \0
		//拷贝字符串数据到新的堆空间
		strcpy(m_name, name);
	}
	void display() { 
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is &quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};

int main() {

	char name[] = { 'b','w','m','\0' };
	Car* car = new Car(100, name);
	Car* car2 = new Car(100, &quot;xiali&quot;);

	//test();
	car-&gt;display();
	car2-&gt;display();

	return 0;
}
</code></pre>
<pre><code>输出：
price is100, name is bwm
price is100, name is xiali
</code></pre>
<h3 id="82-浅拷贝shallow-copy">8.2  浅拷贝（shallow copy）</h3>
<p>浅拷贝：指针类型的变量只会拷贝地址</p>
<h5 id="821-double-free-双重析构双重释放">8.2.1  double free 双重析构双重释放</h5>
<p>由于第二次释放的指向为空，就会报错（导致崩溃）<br>
代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
public:
	Car(int price = 0,const char* name = NULL) :m_price(price) { 
		if (name == NULL) return;
		//申请新的堆空间
		m_name = new char[strlen(name) + 1]{};// 使用 {} 可以保证最后一个字符是 \0
		//拷贝字符串数据到新的堆空间
		strcpy(m_name, name);
	}
	//析构函数
	~Car() {
		if (m_name == NULL) return;
		delete[] m_name; // 删除数组
		m_name = NULL;	
	}
	void display() { 
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is &quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};

int main() {

	Car car1(100, &quot;BWM&quot;);
	Car car2 = car1;
	car2.display();

	return 0;
}
</code></pre>
<p>如下内存剖析</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200408142852844.png" width="80%" alt=""/>
<center>
原理图
<center>
<img src="https://img-blog.csdnimg.cn/20200408142359455.png" width="80%" alt=""/>
<center>
<h3 id="83-深拷贝deep-copy">8.3  深拷贝（deep copy）</h3>
<p>深拷贝：将指针指向的内容拷贝到新的存储空间</p>
<center>
<img src="https://img-blog.csdnimg.cn/2020040814501091.png" width="80%" alt=""/>
<center>
<h5 id="831-深拷贝使用场景">8.3.1  深拷贝使用场景</h5>
<p>当成员变量都是int类型（基本数据类型），没必要使用拷贝构造函数<br>
如果成员变量有指向堆空间的指针，则需要使用拷贝构造函数，实现深拷贝（防止double free）</p>
<p>代码如下： （提示：Car car2(car1); 等价于 Car car3 = car2; 都是用一个已经存在的对象去创建一个新对象，会调用拷贝构造）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car{
	int m_price;
	char* m_name;
	void copy(const char* name) {
		if (name == NULL) return;
		//申请新的堆空间
		m_name = new char[strlen(name) + 1]{};// 使用 {} 可以保证最后一个字符是 \0
		//拷贝字符串数据到新的堆空间
		strcpy(m_name, name);
	}
public:
	Car(int price = 0,const char* name = NULL) :m_price(price) { 
		copy(name);
	}
	//拷贝构造
	Car(const Car &amp;car):m_price(car.m_price) {
		copy(car.m_name);
	}
	//析构函数
	~Car() {
		if (m_name == NULL) return;
		delete[] m_name; // 删除数组
		m_name = NULL;	
	}
	void display() { 
		cout &lt;&lt; &quot;price is&quot; &lt;&lt; m_price &lt;&lt; &quot;, name is &quot; &lt;&lt; m_name &lt;&lt; endl;
	}
};

int main() {

	Car car1(100, &quot;BWM&quot;);
	Car car2 = car1;
	car2.display();

	return 0;
}
</code></pre>
<p>内存剖析</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200408144758819.png" width="80%" alt=""/>
</center>
<h3 id="84-总结">8.4  总结</h3>
<h5 id="841-编译器默认的提供的拷贝是浅拷贝shallow-copy">8.4.1  编译器默认的提供的拷贝是浅拷贝（shallow copy）</h5>
<p>1）将一个对象中所有成员变量的值拷贝到另一个对象<br>
2）如果某个成员变量是个指针，只会拷贝指针中存储的地址值，并不会拷贝指针指向的内存空间<br>
3）可能会导致堆空间多次free的问题</p>
<h5 id="842-如果需要实现深拷贝deep-copy就需要自定义拷贝构造函数">8.4.2  如果需要实现深拷贝（deep copy），就需要自定义拷贝构造函数</h5>
<p>将指针类型的成员变量所指向的内存空间，拷贝到新的内存空间</p>
<p>示例一：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
};
class Person {
	int m_age;
	Car car;
};
int main() {
	return 0;
}
</code></pre>
<p>，这段代码等价于</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
};
class Person {
	int m_age;
	int m_price;
};

int main() {
	return 0;
}
</code></pre>
<p>是否需要拷贝构造根据需求</p>
<hr>
<p>示例二：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
	char* m_name;
};
class Person {
	int m_age;
	Car m_car;
};

int main() {
	return 0;
}
</code></pre>
<p>这段代码等价于</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
	int m_price;
	char* m_name;
};

class Person {
	int m_age;
	int m_price;
	char* m_name;
};


int main() {
	return 0;
}
</code></pre>
<p>是否需要拷贝构造根据需求 m_name 是否需要每个对象都不同</p>
<blockquote>
<p>这块相关内容，可以参考<br>
<a href="https://blog.csdn.net/wanglei19891210/article/details/105223415">C++挖掘程序本质（第二章C++面向对象-中）李明杰-M了个J 配套教材</a>  这篇文章中的 <font color=red>1.内存管理</font>的4张内存图</p>
</blockquote>
<h1 id="9-对象型参数和返回值">9. 对象型参数和返回值</h1>
<p>使用对象类型作为函数的参数或者返回值，可能会产生一些不必要的中间对象</p>
<p><font color=red>在C++中建议：不要直接使用对象类型参数（可以改为指针类型或引用类型）</font></p>
<h3 id="91-对象型参数">9.1 对象型参数</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car()&quot; &lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car)&quot; &lt;&lt; endl;
	}
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

void test(Car car) {
}

int main() {
	Car car;
	test(car);
	return 0;
}
</code></pre>
<pre><code>输出：
Car()
Car(const Car &amp;car)
</code></pre>
<p>输出多了一个拷贝构造函数，因为 test() 函数的<font color=red>参数</font>是Car对象<br>
相当于 void test(Car <font color=red>car=car</font>) {}<br>
Car car=car 这是拷贝构造的本质：由一个已经存在的对象，去创建一个新的对象<br>
所以这才会调用 拷贝构造函数</p>
<p>修改后代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car()&quot; &lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car)&quot; &lt;&lt; endl;
	}
	/*~Car() {
		cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;
	}*/
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

// 由对象改为引用，不用再去调用拷贝构造函数
void test(Car &amp;car) {}
int main() {
	Car car;
	test(car);
	return 0;
}
</code></pre>
<pre><code>输出：Car()
</code></pre>
<h3 id="92-对象型返回值">9.2 对象型返回值</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car() - &quot; &lt;&lt;this&lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	/*~Car() {
		cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;
	}*/
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

Car test2() {
	Car car;
	return car;
}

int main() {
	Car car2;
	car2 = test2();
	return 0;
}
</code></pre>
<pre><code>输出：
Car() - 00F3FD7C
Car() - 00F3FC88
Car(const Car &amp;car) - 00F3FCB0
</code></pre>
<p>输出多了一个拷贝构造函数，因为 test2() 函数的<font color=red>返回值</font>是Car对象<br>
相当于 void test2() { 	Car car;	<font color=red>return car;</font>}<br>
car2 = test2(); 相当于 car2 = Car(test())，在main中将test2进行了拷贝构造<br>
所以这才会调用 拷贝构造函数</p>
<h3 id="93-多此产生拷贝构造的优化">9.3 多此产生拷贝构造的优化</h3>
<p>本来函数执行完会产生一个car对象（存在于main函数的栈空间），但编译器发现car3可以当做存这个car对象的栈空间，就少一次拷贝</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car() - &quot; &lt;&lt;this&lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	/*~Car() {
		cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;
	}*/
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

Car test2() {
	Car car;
	return car;
}

int main() {
	/*Car car;
	test(car);*/
	/*Car car2;
	car2 = test2();*/

	Car car3 = test2();
	return 0;
}
</code></pre>
<pre><code>输出：
Car() - 012FF728
Car(const Car &amp;car) - 012FF810
</code></pre>
<p>由于编译器的优化，由2次Car(const Car &amp;car) 变为了一次</p>
<h1 id="10-匿名对象临时对象">10. 匿名对象（临时对象）</h1>
<p>匿名对象：没有变量名、没有被指针指向的对象，用完后马上调用析构函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car() - &quot; &lt;&lt;this&lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	/*~Car() {
		cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;
	}*/
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

int main() {
	cout &lt;&lt; 1 &lt;&lt; endl;
	Car();
	cout &lt;&lt; 2 &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：
1
Car() - 0115F734
2
</code></pre>
<pre><code class="language-cpp">int main() {
	cout &lt;&lt; 1 &lt;&lt; endl;
	Car().run();
	cout &lt;&lt; 2 &lt;&lt; endl;

	return 0;
}
</code></pre>
<pre><code>输出：
1
Car() - 005FF854
run()
2
</code></pre>
<h3 id="101-传入匿名对象">10.1  传入匿名对象</h3>
<p>匿名对象传入对象类型参数，只调用一次构造与析构</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car() - &quot; &lt;&lt;this&lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Car() {
		cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;
	}
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

// 由对象改为引用，不用再去调用拷贝构造函数
void test(Car car) {
}

int main() {
	test(Car());
	return 0;
}
</code></pre>
<pre><code>输出：
Car() - 012FF9BC
~Car()
</code></pre>
<h3 id="102-返回匿名对象">10.2  返回匿名对象</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {
		cout &lt;&lt; &quot;Car() - &quot; &lt;&lt;this&lt;&lt; endl;
	}
	Car(const Car &amp;car) {
		cout &lt;&lt; &quot;Car(const Car &amp;car) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Car() {
		cout &lt;&lt; &quot;~Car()&quot; &lt;&lt; endl;
	}
	void run() {
		cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;
	}
};

Car test3() {
	return Car();
}

int main() {
	Car car2;
	car2 = test3();

	return 0;
}
</code></pre>
<pre><code>输出：
Car() - 003EF780
Car() - 003EF6B4
~Car()
~Car()
</code></pre>
<h1 id="11-隐式构造">11. 隐式构造</h1>
<p>C++中存在隐式构造的现象：某些情况下，会隐式调用单参数的构造函数</p>
<h3 id="111-正常创建对象">11.1 正常创建对象</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
	int m_age;
public:
	
	Person() {
		cout &lt;&lt; &quot;Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(int age):m_age(age) {
		cout &lt;&lt; &quot;Person(int) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(const Person &amp;person){
		cout &lt;&lt; &quot;Person(const Person &amp;person) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; &quot;~Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;display() -age is &quot;&lt;&lt; m_age &lt;&lt; endl;
	} 
};

int main() {
	Person p1;
	Person p2(10);
	Person p3 = p2;
	return 0;
}
</code></pre>
<pre><code>输出：
Person() - 00D9FAB4
Person(int) - 00D9FAA8
Person(const Person &amp;person) - 00D9FA9C

~Person() - 00D9FA9C
~Person() - 00D9FAA8
~Person() - 00D9FAB4
</code></pre>
<h3 id="112-隐式的调用int类型构造函数">11.2 隐式的调用int类型构造函数</h3>
<p>隐式的调用int类型构造函数，而不是将int数值赋值给person对象</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
	int m_age;
public:
	
	Person() {
		cout &lt;&lt; &quot;Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(int age):m_age(age) {
		cout &lt;&lt; &quot;Person(int) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(const Person &amp;person){
		cout &lt;&lt; &quot;Person(const Person &amp;person) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; &quot;~Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;display() -age is &quot;&lt;&lt; m_age &lt;&lt; endl;
	} 
};




int main() {
	Person p1 = 20;
	// 俩种等价写法
	Person p2(20);

	return 0;
}
</code></pre>
<pre><code>输出：
Person(int) - 013FF960
Person(int) - 013FF954
~Person() - 013FF954
~Person() - 013FF960
</code></pre>
<h3 id="113-对象型参数隐式的调用">11.3 对象型参数（隐式的调用）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
	int m_age;
public:
	
	Person() {
		cout &lt;&lt; &quot;Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(int age):m_age(age) {
		cout &lt;&lt; &quot;Person(int) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(const Person &amp;person){
		cout &lt;&lt; &quot;Person(const Person &amp;person) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; &quot;~Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;display() -age is &quot;&lt;&lt; m_age &lt;&lt; endl;
	} 
};


void test1(Person person) {
}

int main() {
	test1(30);
	return 0;
}
</code></pre>
<pre><code>输出：
Person(int) - 008FFAB0
~Person() - 008FFAB0
</code></pre>
<h3 id="114-对象型返回值隐式的调用">11.4 对象型返回值（隐式的调用）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
	int m_age;
public:
	Person() {
		cout &lt;&lt; &quot;Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(int age):m_age(age) {
		cout &lt;&lt; &quot;Person(int) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(const Person &amp;person){
		cout &lt;&lt; &quot;Person(const Person &amp;person) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; &quot;~Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;display() -age is &quot;&lt;&lt; m_age &lt;&lt; endl;
	} 
};

void test1(Person person) {
}

Person test2() {
	return 40;
	//等价于
	//return Person(40);
}

int main() {
	test2();

	return 0;
}
</code></pre>
<pre><code>输出：
Person(int) - 00B3FB80
~Person() - 00B3FB80
</code></pre>
<h3 id="115-先显示创建对象再隐式创建对象">11.5 先显示创建对象，再隐式创建对象</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
	int m_age;
public:
	Person() {
		cout &lt;&lt; &quot;Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(int age):m_age(age) {
		cout &lt;&lt; &quot;Person(int) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(const Person &amp;person){
		cout &lt;&lt; &quot;Person(const Person &amp;person) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; &quot;~Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;display() -age is &quot;&lt;&lt; m_age &lt;&lt; endl;
	} 
};


void test1(Person person) {

}

Person test2() {
	return 40;
}

int main() {
	Person p1;
	p1 = 40;

	return 0;
}
</code></pre>
<pre><code>输出：
Person() - 010FFAB0
Person(int) - 010FF9E4
~Person() - 010FF9E4
~Person() - 010FFAB0
</code></pre>
<h3 id="116-font-colorredexplicitfont-禁止调用隐式构造">11.6  <font color=red>explicit</font>  禁止调用隐式构造</h3>
<p>为了防止代码奇异，阅读者混淆，可读性很差</p>
<pre><code class="language-cpp">class Person {
	int m_age;
public:
	Person() {
		cout &lt;&lt; &quot;Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	explicit Person(int age):m_age(age) {
		cout &lt;&lt; &quot;Person(int) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	Person(const Person &amp;person){
		cout &lt;&lt; &quot;Person(const Person &amp;person) - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; &quot;~Person() - &quot; &lt;&lt; this &lt;&lt; endl;
	}
	void display() {
		cout &lt;&lt; &quot;display() -age is &quot;&lt;&lt; m_age &lt;&lt; endl;
	} 
};
</code></pre>
<h1 id="12-编译器自动生成的构造函数">12. 编译器自动生成的构造函数</h1>
<p>C++的编译器在某些特定的情况下，会给类自动生成无参的构造函数</p>
<h3 id="121-成员变量在声明的同时进行了初始化">12.1 成员变量在声明的同时进行了初始化</h3>
<p>默认不写构造函数，创建对象（非new Person()）的方式，不会生成构造函数，如下图：</p>
<center>
<img src="https://img-blog.csdnimg.cn/2020040820553993.png" width="80%" alt=""/>
</center>
<p>成员变量在声明的同时进行了初始化，会产生构造函数</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
using namespace std;

class Person {
public:
	int m_age =5;
};

int main() {
	Person person;

	return 0;
}
</code></pre>
<center>
<img src="https://img-blog.csdnimg.cn/20200408210846548.png" width="80%" alt=""/>
</center>
<h3 id="122-有定义虚函数">12.2 有定义虚函数</h3>
<p>定义虚函数，会产生构造函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
public:
	int m_age;
	virtual void run() {
	}
};

int main() {
	Person person;

	return 0;
}
</code></pre>
<center>
<img src="https://img-blog.csdnimg.cn/20200408211042917.png" width="80%" alt=""/>
</center>
<h3 id="123-虚继承了其他类">12.3 虚继承了其他类</h3>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
using namespace std;

class Person {
public:
	int m_age;
	virtual void run() {
	}
};

class Student:virtual public Person {
public:
	int m_age;
	virtual void run() {
	}
};

int main() {
	Person person;

	return 0;
}
</code></pre>
<center>
<img src="https://img-blog.csdnimg.cn/20200408213906787.png" width="80%" alt=""/>
</center>
<h3 id="124-包含了对象类型的成员且这个成员有构造函数编译器生成或自定义">12.4 包含了对象类型的成员，且这个成员有构造函数（编译器生成或自定义）</h3>
<p>person 包含了car对象，如何car内没有构造函数，则编译器不会对person创建构造函数<br>
如下代码：person会生成构造函</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price;
	Car() {}
};


class Person {
public:
	Car m_car;
};

int main() {
	Person person;

	return 0;
}
</code></pre>
<center>
<img src="https://img-blog.csdnimg.cn/20200408214237199.png" width="80%" alt=""/>
</center>
<p>person会生成构造函</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Car {
public:
	int m_price=0;
};

class Person {
public:
	Car m_car;
};

int main() {
	Person person;

	return 0;
}
</code></pre>
<h3 id="125-父类有构造函数编译器生成或自定义">12.5 父类有构造函数（编译器生成或自定义）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Person {
public:
	int m_price=0;
};

class Student : public Person {
public:
	
};

int main() {
	Student student;

	return 0;
}
</code></pre>
<h3 id="126-总结">12.6 总结</h3>
<p>对象创建后，需要做一些额外操作时（比如内存操作、函数调用），编译器一般都会其自动生成无参的构造函数</p>
<h1 id="13友元">13.	友元</h1>
<p>友元包括友元函数和友元类<br>
友元函数和友元类不能混用<br>
友元不受public、private、protected限制</p>
<p>引入使用场景，代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Point
{
private:
	int m_x;
	int m_y;
public:
	int getX() { return m_x; }
	int getY() { return m_y; }
	Point(int x, int y) :m_x(x), m_y(y) {}
	void display() {
		cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;,&quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
	}

};
Point add(Point p1 ,Point p2) {
	return Point(p1.getX() + p2.getX(), p1.getY()+p2.getY());
}
int main() {
	Point p1(10, 20);
	Point p2(20, 30);
	Point p3 = add(p1, p2);
	p3.display();

	return 0;
}

</code></pre>
<p>如果这里频繁使用 add() 函数，每执行一次add()就调用4次 get() 函数，而且是只读<br>
这里如果在add() 里面访问类中的私有成员变量</p>
<h3 id="131-友元函数">13.1 友元函数</h3>
<p>如果将函数A（非成员函数，即：类外部）生命为类C的友元函数，那么在函数A内部就能直接访问类C对象的所有成员</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Point
{
	friend Point add(Point, Point);
private:
	int m_x;
	int m_y;
public:
	int getX() { return m_x; }
	int getY() { return m_y; }

	Point(int x, int y) :m_x(x), m_y(y) {}
	void display() {
		cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;,&quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
	}

};

Point add(Point p1 ,Point p2) {
	//return Point(p1.getX() + p2.getX(), p1.getY()+p2.getY());
	return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);

}


int main() {
	Point p1(10, 20);
	Point p2(20, 30);
	Point p3 = add(p1, p2);
	p3.display();

	return 0;
}
</code></pre>
<pre><code>输出：(30,50)
</code></pre>
<h3 id="132-友元类">13.2 友元类</h3>
<p>如果将类A声明为类C的友元类，那么在类A的所有成员函数内部都能直接访问类C对象的所有成员</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Point
{
	//friend Point add(Point, Point);
	friend class Math;
private:
	int m_x;
	int m_y;
public:
	int getX() { return m_x; }
	int getY() { return m_y; }

	Point(int x, int y) :m_x(x), m_y(y) {}
	void display() {
		cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;,&quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
	}
};

class Math {
public:
	Point add(Point p1, Point p2) {
		//return Point(p1.getX() + p2.getX(), p1.getY()+p2.getY());
		return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);

	}
	void test() {
	
		Point p1(10, 20);
		p1.m_x = 10;

	}
};

int main() {
	Point p1(10, 20);
	Point p2(20, 30);
	Point p3 = Math().add(p1, p2);
	p3.display();

	return 0;
}


</code></pre>
<h3 id="133-利弊">13.3 利弊</h3>
<p>友元破坏了面向对象的封装性<br>
在某些频繁访问成员变量的地方可以提高性能</p>
<h1 id="14-内部类">14. 内部类</h1>
<p>定义：如果将类A按定义在类C的内部，那么类A就是一个内部类（嵌套类）</p>
<h3 id="141-使用场景">14.1 使用场景</h3>
<p>如果需要对一个类进行访问权限控制-使用内部类</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Person{
	int m_age;
public:
	class Car {
		int m_price;
	};
};

int main() {
	Person::Car car1;
	return 0;
}
</code></pre>
<h3 id="142-内部类的特点">14.2 内部类的特点</h3>
<h5 id="1421-支持public-protected-private权限">14.2.1  支持public、protected、private权限</h5>
<p>可以通过权限达到对类的控制</p>
<center>
<img src="https://img-blog.csdnimg.cn/20200410152248916.png" width="80%" alt=""/>
</center>
<h5 id="1422-成员函数可以直接访问其外部类对象的所有成员反过来则不行">14.2.2  成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Person{
	int m_age;
	void test(){
		Car car;
		car.m_price = 10; // 报错
	}

protected:
	class Car {
		int m_price;
		void run() {
			Person person;
			person.m_age = 10;
		}
	};
};

int main() {
	//Person::Car car1;

	return 0;
}
</code></pre>
<center>
<img src="https://img-blog.csdnimg.cn/2020041015261762.png" width="80%" alt=""/>
</center>
<h5 id="1423-成员函数可以直接不带类名-对象名访问其外部类的static成员">14.2.3  成员函数可以直接不带类名、对象名访问其外部类的static成员</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Person{
	static int m_age;
	static void test(){
	}

protected:
	class Car {
		int m_price;
		void run() {
			m_age = 10;
			test();
			/*Person person;
			person.m_age = 10;*/
		}
	};
};

int main() {
	//Person::Car car1;
	return 0;
}
</code></pre>
<h5 id="1424-不会影响外部类的内存布局">14.2.4  不会影响外部类的内存布局</h5>
<p>person 对象 只占4个字节（age的大小）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class  Person{
	 int m_age;
	 void test(){
		//Car car;
		//car.m_price = 10; // 报错
	}

protected:
	class Car {
		int m_price;
		void run() {
		}
	};
};

int main() {
	//Person::Car car1;
	Person person;
	return 0;
}
</code></pre>
<h5 id="1425-可以再外部类内部声明在外部类外面进行定义">14.2.5  可以再外部类内部声明，在外部类外面进行定义</h5>
<p>内部类-声明和实现分离</p>
<center>
<img src="https://img-blog.csdnimg.cn/2020041015405349.png" width="80%" alt=""/>
</center>
<h1 id="15-局部类">15. 局部类</h1>
<p>在意函数内部定义的类，成为局部类</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void test() {
	//局部类
	class Car {
	};
}
int main() {
	return 0;
}
</code></pre>
<h3 id="151-局部类得特点">15.1 局部类得特点</h3>
<h5 id="1511-作用域仅限于所在函数内部">15.1.1  作用域仅限于所在函数内部</h5>
<h5 id="1512-其所有的成员必须定义在类内部不允许定义font-colorbluestaticfont成员变量">15.1.2  其所有的成员必须定义在类内部，不允许定义<font color=blue>static</font>成员变量</h5>
<p>因为 static 的初始化要在类的外部，与上一条规则冲突</p>
<h5 id="1513-成员函数不能直接访问函数的局部变量font-colorbluestaticfont-变量除外">15.1.3  成员函数不能直接访问函数的局部变量（<font color=blue>static</font> 变量除外）</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void test() {
	static int age = 10;
	//局部类
	class Car {
		void run() {
			age = 20;
		}
	};
}

int main() {
	return 0;
}
</code></pre>
<h5 id="1514-不会影响外部类的内存布局">15.1.4  不会影响外部类的内存布局</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void test() {
	static int age = 10;
	//局部类
	class Car {
	public:
		void run() {
			age = 20;
		}
	};
	Car car;
	car.run();
}

int main() {
	return 0;
}
</code></pre>
<p>其中这段代码，是放在代码段（区）的不占用其他内存</p>
<pre><code class="language-cpp">	//局部类
	class Car {
	public:
		void run() {
			age = 20;
		}
	};
</code></pre>
<h5 id="1515-可以再外部类内部声明在外部类外面进行定义">15.1.5  可以再外部类内部声明，在外部类外面进行定义</h5>
<blockquote>
<p>到此面向对象部份全部结束</p>
</blockquote>
<blockquote>
<p>主要以b站免费学习资源<br>
打造同进度学习的同学<br>
在没有up主回答的情况下<br>
通过一起学习组队可以互相解决观看视频中自己出现的问题，通过教学相长的方式，将知识可以牢固掌握。<br>
关于文章中的问题欢迎指正，如有其它问题也可以私信，看到会第一时间回复<br>
我们的目标是：学习是我们终身的任务</p>
</blockquote>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://holyson.github.io/ctra.github.io/tag/ZZ4tynyo3/" class="tag">
                    技术篇
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://holyson.github.io/ctra.github.io/post/1-fen-zhong-da-zao-ge-ren-bo-ke/">
                  <h3 class="post-title">
                    五分钟零成本搭建个人博客
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'c8095f1dffb004fc399d',
        clientSecret: '47a97b6ab252e98d6f37aabdf74dd73c39722e6d',
        repo: 'blog-comment',
        owner: 'Holyson',
        admin: ['Holyson'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
